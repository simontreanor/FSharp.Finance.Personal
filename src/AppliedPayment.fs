namespace FSharp.Finance.Personal

open Scheduling

/// functions for handling received payments and calculating interest and/or charges where necessary
module AppliedPayment =

    open Calculation
    open DateDay
    open Formatting

    /// a generated payment, where applicable
    [<Struct; StructuredFormatDisplay("{Html}")>]
    type GeneratedPayment =
        /// no generated payment is required
        | NoGeneratedPayment
        /// the payment value will be generated later
        | ToBeGenerated
        /// the generated payment value
        | GeneratedValue of int64<Cent>

        /// HTML formatting to display the generated payment in a readable format
        member x.Html =
            match x with
            | NoGeneratedPayment
            | ToBeGenerated -> "<i>n/a</i>"
            | GeneratedValue gv -> formatCent gv

    /// a generated payment, where applicable
    module GeneratedPayment =
        /// the total value of the generated payment
        let total =
            function
            | GeneratedValue gv -> gv
            | _ -> 0L<Cent>

    /// a charge applied to an actual payment
    [<Struct; StructuredFormatDisplay("{Html}")>]
    type AppliedCharge = {
        /// the type of charge
        ChargeType: Charge.ChargeType
        /// the total charge
        Total: int64<Cent>
    } with

        /// HTML formatting to display the applied charge in a readable format
        member ac.Html = $"<i>{ac.ChargeType}</i> {formatCent ac.Total}"

    /// the status of a payment made by the customer
    [<Struct; StructuredFormatDisplay("{Html}")>]
    type PaymentStatus =
        /// no payment is required on the specified day
        | NoneScheduled
        /// a payment has been initiated but not yet confirmed
        | PaymentPending
        /// a scheduled payment was made in full and on time
        | PaymentMade
        /// no payment is due on the specified day because of earlier extra-/overpayments
        | NothingDue
        /// a scheduled payment is not paid on time, but is paid within the window
        | PaidLaterInFull
        /// a scheduled payment is not paid on time, but is partially paid within the window
        | PaidLaterOwing of Shortfall: int64<Cent>
        /// a scheduled payment was missed completely, i.e. not paid within the window
        | MissedPayment
        /// a scheduled payment was made on time but not in the full amount
        | Underpayment
        /// a scheduled payment was made on time but exceeded the full amount
        | Overpayment
        /// a payment was made on a day when no payments were scheduled
        | ExtraPayment
        /// a refund was processed
        | Refunded
        /// a scheduled payment is in the future (seen from the evaluation date)
        | NotYetDue
        /// a scheduled payment has not been made on time but is within the late-charge grace period
        | PaymentDue
        /// a payment generated by a settlement quote
        | Generated
        /// no payment needed because the loan has already been settled
        | NoLongerRequired
        /// a schedule item generated to show the balances on the evaluation date
        | InformationOnly

        /// HTML formatting to display the payment status in a readable format
        member ps.Html =
            match ps with
            | NoneScheduled -> "<i>none scheduled</i>"
            | PaymentPending -> "<i>payment pending</i>"
            | PaymentMade -> "<i>payment made</i>"
            | NothingDue -> "<i>nothing due</i>"
            | PaidLaterInFull -> "<i>paid later in full</i>"
            | PaidLaterOwing shortfall -> $"<i>paid later owing</i> {formatCent shortfall}"
            | MissedPayment -> "<i>missed payment</i>"
            | Underpayment -> "<i>underpayment</i>"
            | Overpayment -> "<i>overpayment</i>"
            | ExtraPayment -> "<i>extra payment</i>"
            | Refunded -> "<i>refunded</i>"
            | NotYetDue -> "<i>not yet due</i>"
            | PaymentDue -> "<i>payment due</i>"
            | Generated -> "<i>generated</i>"
            | NoLongerRequired -> "<i>no longer required</i>"
            | InformationOnly -> "<i>information only</i>"

    /// an actual payment made on a particular day, optionally with charges applied, with the net effect and payment status calculated
    type AppliedPayment = {
        /// the amount of any scheduled payment due on the current day
        ScheduledPayment: ScheduledPayment
        /// the amounts of any actual payments made on the current day
        ActualPayments: Map<int, ActualPayment>
        /// a payment generated by the system e.g. to calculate a settlement figure
        GeneratedPayment: GeneratedPayment
        /// details of any charges applied
        AppliedCharges: AppliedCharge array
        /// the net effect of any payments made on the current day
        NetEffect: int64<Cent>
        /// the payment status based on the payments made on the current day
        PaymentStatus: PaymentStatus
    }

    type private SP = {
        spDay: int<OffsetDay>
        spTotal: int64<Cent>
    }

    type private AP = {
        apDay: int<OffsetDay>
        apIndex: int
        apTotal: int64<Cent>
        spp: SP list
    }

    /// groups payments by day, applying actual payments, adding a payment status and optionally a late payment charge if underpaid
    let applyPayments (parameters: Parameters) actualPayments scheduledPayments =
        // guard against empty maps
        if Map.isEmpty scheduledPayments then
            Map.empty
        else
            let evaluationDay =
                parameters.Basic.EvaluationDate |> OffsetDay.fromDate parameters.Basic.StartDate

            // check to see if any pending payments have timed out
            let actualPayments =
                actualPayments
                |> Map.map (fun d app ->
                    if isTimedOut parameters.Advanced.PaymentConfig.Timeout evaluationDay d then
                        app
                        |> Map.map (fun i ap ->
                            match ap.ActualPaymentStatus with
                            | ActualPaymentStatus.Pending payment -> {
                                ap with
                                    ActualPaymentStatus = ActualPaymentStatus.TimedOut payment
                              }
                            | _ -> ap
                        )
                    else
                        app
                )

            // get a list of unique days on which either a scheduled payment is due or an actual payment is made
            let days =
                [|
                    scheduledPayments |> Map.keys |> Seq.toArray
                    actualPayments |> Map.keys |> Seq.toArray
                |]
                |> Array.concat
                |> Array.distinct
                |> Array.sort

            // create a map of charge holidays
            let chargeHolidays =
                match parameters.Advanced.ChargeConfig with
                | Some cc ->
                    cc.ChargeTypes
                    |> Map.map (fun ct cc ->
                        Charge.ChargeConditions.getHolidays parameters.Basic.StartDate cc.ChargeHolidays
                    )
                | None -> Map.empty

            // create a map of applied payments
            let appliedPaymentMap =
                days
                |> Array.mapFold
                    (fun aggregateAppliedCharges offsetDay ->
                        // get any scheduled payment due on the day
                        let scheduledPayment' =
                            scheduledPayments
                            |> Map.tryFind offsetDay
                            |> Option.defaultValue ScheduledPayment.zero
                        // get any actual payments made on the day
                        let actualPayments' =
                            actualPayments |> Map.tryFind offsetDay |> Option.defaultValue Map.empty
                        // of the actual payments made on the day, sum any that are confirmed or written off
                        let confirmedPaymentTotal =
                            actualPayments'
                            |> Map.values
                            |> Seq.sumBy (fun ap ->
                                match ap.ActualPaymentStatus with
                                | ActualPaymentStatus.Confirmed ap -> ap
                                | ActualPaymentStatus.WriteOff ap -> ap
                                | _ -> 0L<Cent>
                            )
                        // of the actual payments made on the day, sum any that are still pending
                        let pendingPaymentTotal =
                            actualPayments'
                            |> Map.values
                            |> Seq.sumBy (fun ap ->
                                match ap.ActualPaymentStatus with
                                | ActualPaymentStatus.Pending ap -> ap
                                | _ -> 0L<Cent>
                            )
                        // calculate the net effect and payment status for the day
                        let netEffect, paymentStatus =
                            // if a payment is pending, this overrides any other net effect or status for the day
                            if pendingPaymentTotal > 0L<Cent> then
                                pendingPaymentTotal + confirmedPaymentTotal, PaymentPending
                            // otherwise, calculate as normal
                            else
                                match ScheduledPayment.total scheduledPayment', confirmedPaymentTotal with
                                // no payments due or made (possibly the day is included for information only, e.g. to force calculation of balances)
                                | 0L<Cent>, 0L<Cent> -> 0L<Cent>, NoneScheduled
                                // no payment due, but a refund issued
                                | 0L<Cent>, cpt when cpt < 0L<Cent> -> cpt, Refunded
                                // no payment due, but a payment made
                                | 0L<Cent>, cpt -> cpt, ExtraPayment
                                // a payment due on or before the day
                                | spt, cpt when
                                    cpt < spt
                                    && offsetDay <= evaluationDay
                                    && int offsetDay + int parameters.Advanced.PaymentConfig.Timeout
                                       >= int evaluationDay
                                    ->
                                    match parameters.Advanced.SettlementDay with
                                    // settlement requested on a future day
                                    | SettlementDay.SettlementOnEvaluationDay when evaluationDay > offsetDay ->
                                        0L<Cent>, PaymentDue
                                    // settlement requested on the day, requiring a generated payment to be calculated (calculation deferred until amortisation schedule is generated)
                                    | SettlementDay.SettlementOnEvaluationDay when evaluationDay = offsetDay ->
                                        0L<Cent>, Generated
                                    // no settlement on day, or statement requested
                                    | _ -> spt, PaymentDue
                                // a payment due on a future day
                                | spt, _ when offsetDay > evaluationDay -> spt, NotYetDue
                                // a payment due but no payment made
                                | spt, 0L<Cent> when spt > 0L<Cent> -> 0L<Cent>, MissedPayment
                                // a payment due but the payment made is less than what's due
                                | spt, cpt when cpt < spt -> cpt, Underpayment
                                // a payment due but the payment made is more than what's due
                                | spt, cpt when cpt > spt -> cpt, Overpayment
                                // any other payment made
                                | _, cpt -> cpt, PaymentMade

                        // calculate any charge types incurred
                        let chargeTypes =
                            actualPayments'
                            |> Map.values
                            |> Seq.choose (fun ap ->
                                // failed payments that incurred a charge
                                match ap.ActualPaymentStatus with
                                | ActualPaymentStatus.Failed(_, ValueSome chargeType) -> Some chargeType
                                | _ -> None
                            )
                            |> Seq.toArray
                            |> Array.append (
                                // missed payments and underpayments incur a late payment charge
                                match paymentStatus with
                                | MissedPayment
                                | Underpayment -> [| Charge.ChargeType.LatePayment |]
                                | _ -> [||]
                            )

                        // calculate the total of any charges incurred
                        let appliedCharges =
                            chargeTypes
                            |> Array.choose (fun ct ->
                                match parameters.Advanced.ChargeConfig with
                                | Some cc when cc.ChargeTypes.ContainsKey ct ->
                                    let chargeConditions = cc.ChargeTypes[ct]

                                    if chargeHolidays[ct] |> Array.exists ((=) offsetDay) then
                                        None
                                    else
                                        Some {
                                            ChargeType = ct
                                            Total = chargeConditions.Value
                                        }
                                | _ -> None
                            )

                        let groupedAppliedCharges =
                            appliedCharges
                            |> Array.groupBy _.ChargeType
                            |> Array.collect (fun (ct, ac) ->
                                if Array.isEmpty ac then
                                    [||]
                                else
                                    let chargeConditions = parameters.Advanced.ChargeConfig.Value.ChargeTypes[ct]

                                    match chargeConditions.ChargeGrouping with
                                    | Charge.ChargeGrouping.OneChargeTypePerDay -> Array.take 1 ac
                                    | Charge.ChargeGrouping.OneChargeTypePerSchedule ->
                                        if aggregateAppliedCharges |> Array.exists (fun ac -> ac.ChargeType = ct) then
                                            [||]
                                        else
                                            Array.take 1 ac
                                    | Charge.ChargeGrouping.AllChargesApplied -> ac
                            )
                        // create the applied payment
                        let appliedPayment = {
                            ScheduledPayment = scheduledPayment'
                            ActualPayments = actualPayments'
                            GeneratedPayment = NoGeneratedPayment
                            AppliedCharges = groupedAppliedCharges
                            NetEffect = netEffect
                            PaymentStatus = paymentStatus
                        }

                        let newAggregateAppliedCharges = Array.append appliedCharges aggregateAppliedCharges
                        // add the day to create a key-value pair for mapping
                        (offsetDay, appliedPayment), newAggregateAppliedCharges
                    )
                    Array.empty<AppliedCharge>
                |> fst
                // convert the array to a map
                |> Map.ofArray

            // for settlements or statements, adds a new applied payment or modifies an existing one (generated-payment and payment-status fields)
            let appliedPayments day generatedPayment paymentStatus =
                // if the day is already in the applied payment map, add a placeholder generated payment to the day
                if appliedPaymentMap |> Map.containsKey day then
                    appliedPaymentMap
                    |> Map.map (fun d ap ->
                        if d = day then
                            {
                                ap with
                                    GeneratedPayment = generatedPayment
                            }
                        else
                            ap
                    )
                // otherwise, add a new applied payment to the map
                else
                    let newAppliedPayment = {
                        ScheduledPayment = ScheduledPayment.zero
                        ActualPayments = Map.empty
                        GeneratedPayment = generatedPayment
                        AppliedCharges = [||]
                        NetEffect = 0L<Cent>
                        PaymentStatus = paymentStatus
                    }

                    appliedPaymentMap |> Map.add day newAppliedPayment

            let mapScheduledPayments appliedPayments =
                let scheduledPaymentList =
                    scheduledPayments
                    |> Map.toList
                    |> List.map (fun (d, sp) -> {
                        spDay = d
                        spTotal = ScheduledPayment.total sp
                    })

                let actualPaymentList =
                    actualPayments
                    |> Map.toList
                    |> List.collect (fun (d, app) ->
                        app
                        |> Map.toList
                        |> List.map (fun (i, ap) -> {
                            apDay = d
                            apIndex = i
                            apTotal = ActualPayment.totalMade ap
                            spp = []
                        })
                    )

                let spLastDay =
                    scheduledPaymentList
                    |> List.tryLast
                    |> Option.map _.spDay
                    |> Option.defaultValue 0<OffsetDay>

                let applyPayment (spp: SP list) (appliedPaymentTotal: int64<Cent>) =
                    if appliedPaymentTotal >= 0L<Cent> then
                        let folder (apt, sppCovered, sppUncovered) sp =
                            if apt >= sp.spTotal then // full payment can be covered
                                apt - sp.spTotal, sp :: sppCovered, sppUncovered
                            elif apt > 0L<Cent> then // partial payment - split here
                                let spCovered = { sp with spTotal = apt }
                                let spUncovered = { sp with spTotal = sp.spTotal - apt }
                                0L<Cent>, spCovered :: sppCovered, spUncovered :: sppUncovered
                            else // no payment - add to uncovered
                                0L<Cent>, sppCovered, sp :: sppUncovered

                        let remainder, sppCovered, sppUncovered =
                            spp |> List.fold folder (appliedPaymentTotal, [], [])

                        let sppCovered' =
                            if remainder > 0L<Cent> then
                                {
                                    spDay = spLastDay
                                    spTotal = remainder
                                }
                                :: sppCovered
                            else
                                sppCovered

                        List.rev sppCovered', List.rev sppUncovered
                    else
                        [
                            {
                                spDay = spLastDay
                                spTotal = appliedPaymentTotal
                            }
                        ],
                        spp

                let result =
                    actualPaymentList
                    |> List.mapFold
                        (fun spp ap ->
                            let sppCovered, sppUncovered = applyPayment spp ap.apTotal
                            { ap with spp = sppCovered }, sppUncovered
                        )
                        scheduledPaymentList
                    |> fst
                    |> List.map (fun ap ->
                        (ap.apDay, ap.apIndex), ap.spp |> List.map (fun sp -> sp.spDay, sp.spTotal) |> Map.ofList
                    )
                    |> Map.ofList

                appliedPayments
                |> Map.map (fun d ap -> {
                    ap with
                        ActualPayments =
                            ap.ActualPayments
                            |> Map.map (fun i actp -> {
                                actp with
                                    ScheduledPayments = result[d, i]
                            })
                })

            // add or modify the applied payments depending on whether the intended purpose is a settlement or just a statement
            match parameters.Advanced.SettlementDay with
            // settlement on the evaluation day
            | SettlementDay.SettlementOnEvaluationDay -> appliedPayments evaluationDay ToBeGenerated Generated
            // statement only
            | SettlementDay.NoSettlement -> appliedPayments evaluationDay NoGeneratedPayment InformationOnly
            |> mapScheduledPayments
