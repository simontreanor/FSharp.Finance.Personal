namespace FSharp.Finance.Personal

/// calculating the principal balance over time, taking into account the effects of charges, interest and fee
module Amortisation =

    open AppliedPayment
    open Calculation
    open DateDay
    open Formatting
    open Scheduling

    /// the day of the amortisation schedule, which can be a normal day, evaluation day or settlement day
    [<Struct>]
    type OffsetDayType =
        | OffsetDay
        | EvaluationDay
        | SettlementDay

    /// the day of the amortisation schedule, which can be a normal day, evaluation day or settlement day
    [<Struct>]
    module OffsetDayType =
        /// HTML formatting to display the amortisation day in a readable format
        let toHtml (offsetDay: int<OffsetDay>) offsetDayType =
            match offsetDayType with
            | OffsetDay -> $"<b>{offsetDay}</b>"
            | EvaluationDay -> $"&#x2605;&nbsp;<b>{offsetDay}</b>"
            | SettlementDay -> $"&#x2713;&nbsp;<b>{offsetDay}</b>"

    /// the status of the balance on a given offset day
    [<Struct; StructuredFormatDisplay("{Html}")>]
    type BalanceStatus =
        /// the balance has been settled in full
        | ClosedBalance
        /// the balance is open, meaning further payments will be required to settle it
        | OpenBalance
        /// due to an overpayment or a refund of charges, a refund is due
        | RefundDue
        /// a refund was made but this left a positive principal balance, meaning the customer has been over-refunded
        | OverRefunded

        /// HTML formatting to display the balance status in a readable format
        member bs.Html =
            match bs with
            | ClosedBalance -> "closed"
            | OpenBalance -> "open"
            | RefundDue -> "refund due"
            | OverRefunded -> "over-refunded"

    /// a breakdown of how an actual payment is apportioned to principal, fee, interest and charges
    type Apportionment = {
        PrincipalPortion: int64<Cent>
        FeePortion: int64<Cent>
        InterestPortion: int64<Cent>
        ChargesPortion: int64<Cent>
    }

    /// a breakdown of how an actual payment is apportioned to principal, fee, interest and charges
    module Apportionment =
        /// add principal, fee, interest and charges to an existing apportionment
        let add principal fee interest charges apportionment = {
            apportionment with
                PrincipalPortion = apportionment.PrincipalPortion + principal
                FeePortion = apportionment.FeePortion + fee
                InterestPortion = apportionment.InterestPortion + interest
                ChargesPortion = apportionment.ChargesPortion + charges
        }

        /// a default value for an apportionment, with all portions set to zero
        let zero = {
            PrincipalPortion = 0L<Cent>
            FeePortion = 0L<Cent>
            InterestPortion = 0L<Cent>
            ChargesPortion = 0L<Cent>
        }

        /// the total value of all the portions of an apportionment
        let total apportionment =
            apportionment.PrincipalPortion
            + apportionment.FeePortion
            + apportionment.InterestPortion
            + apportionment.ChargesPortion

    /// amortisation schedule item showing apportionment of payments to principal, fee, interest and charges
    type ScheduleItem = {
        /// the offset day type
        OffsetDayType: OffsetDayType
        /// the date of amortisation
        OffsetDate: Date
        /// any advance made on the current day, typically the principal on day 0 for a single-advance transaction
        Advances: int64<Cent> array
        /// any payment scheduled on the current day
        ScheduledPayment: ScheduledPayment
        /// the window during which a scheduled payment can be made; if the date is missed, the payment is late, but if the window is missed, the payment is missed
        Window: int
        /// any payment scheduled on the current day
        PaymentDue: int64<Cent>
        /// any payments actually made on the current day
        ActualPayments: Map<int, ActualPayment>
        /// how much of the scheduled payment was paid by which actual payment
        PaidBy: Map<(int<OffsetDay> * int), int64<Cent>>
        /// a payment generated by the system e.g. to calculate a settlement figure
        GeneratedPayment: GeneratedPayment
        /// the net effect of the scheduled and actual payments, or, for future days, what the net effect would be if the scheduled payment was actually made
        NetEffect: int64<Cent>
        /// the status based on the payments and net effect
        PaymentStatus: PaymentStatus
        /// the overall balance status
        BalanceStatus: BalanceStatus
        /// any new charges incurred between the previous amortisation day and the current day
        NewCharges: AppliedCharge array
        /// the portion of the net effect assigned to the charges
        ChargesPortion: int64<Cent>
        /// the actuarial interest accruable between the previous amortisation day and the current day
        ActuarialInterest: decimal<Cent>
        /// the new interest charged between the previous amortisation day and the current day, less any initial interest
        NewInterest: decimal<Cent>
        /// the portion of the net effect assigned to the interest
        InterestPortion: int64<Cent>
        /// any fee rebate, on the final amortisation day, if the fee is pro-rated in the event of early settlement
        FeeRebate: int64<Cent>
        /// the portion of the net effect assigned to the fee
        FeePortion: int64<Cent>
        /// the portion of the net effect assigned to the principal
        PrincipalPortion: int64<Cent>
        /// the charges balance to be carried forward
        ChargesBalance: int64<Cent>
        /// the interest balance to be carried forward
        InterestBalance: decimal<Cent>
        /// the fee balance to be carried forward
        FeeBalance: int64<Cent>
        /// the principal balance to be carried forward
        PrincipalBalance: int64<Cent>
        /// the settlement figure as of the current day
        SettlementFigure: int64<Cent>
        /// the pro-rated fee as of the current day
        FeeRebateIfSettled: int64<Cent>
    }

    /// amortisation schedule item showing apportionment of payments to principal, fee, interest and charges
    module ScheduleItem =
        /// a default value with no data
        let zero = {
            OffsetDayType = OffsetDay
            OffsetDate = Unchecked.defaultof<Date>
            Advances = [||]
            ScheduledPayment = ScheduledPayment.zero
            Window = 0
            PaymentDue = 0L<Cent>
            ActualPayments = Map.empty
            PaidBy = Map.empty
            GeneratedPayment = NoGeneratedPayment
            NetEffect = 0L<Cent>
            PaymentStatus = NoneScheduled
            BalanceStatus = OpenBalance
            ActuarialInterest = 0m<Cent>
            NewInterest = 0m<Cent>
            NewCharges = [||]
            PrincipalPortion = 0L<Cent>
            FeePortion = 0L<Cent>
            InterestPortion = 0L<Cent>
            ChargesPortion = 0L<Cent>
            FeeRebate = 0L<Cent>
            PrincipalBalance = 0L<Cent>
            FeeBalance = 0L<Cent>
            InterestBalance = 0m<Cent>
            ChargesBalance = 0L<Cent>
            SettlementFigure = 0L<Cent>
            FeeRebateIfSettled = 0L<Cent>
        }

        let private formatActualPayments =
            Map.map (fun (index: int) actualPayment -> $"<b>{index}</b>&nbsp;{actualPayment}")
            >> Map.values
            >> String.concat "<br/>"
            >> _.Replace(" ", "&nbsp;")

        let private formatPaidBy =
            Map.map (fun (day: int<OffsetDay>, index: int) amount -> $"<b>{day}#{index}</b>&nbsp;{formatCent amount}")
            >> Map.values
            >> String.concat "<br/>"
            >> _.Replace(" ", "&nbsp;")

        /// formats the schedule item as an HTML row
        let toHtmlRow (p: Parameters) settlementDay offsetDay scheduleItem =
            let fields =
                [|
                    yield "", $"{OffsetDayType.toHtml offsetDay scheduleItem.OffsetDayType}"
                    yield " style=\"white-space: nowrap;\"", $"%A{scheduleItem.OffsetDate}"
                    yield "", $"{scheduleItem.Advances |> Array.map formatCent |> Array.toStringOrNa}"
                    yield " style=\"white-space: nowrap;\"", $"{scheduleItem.ScheduledPayment}"
                    yield "", $"{scheduleItem.Window}"
                    yield "", $"{formatCent scheduleItem.PaymentDue}"
                    yield "", $"""{formatActualPayments scheduleItem.ActualPayments}"""
                    yield "", $"""{formatPaidBy scheduleItem.PaidBy}"""
                    if settlementDay <> SettlementDay.NoSettlement then
                        yield "", $"{scheduleItem.GeneratedPayment}"
                    yield "", $"{formatCent scheduleItem.NetEffect}"
                    yield "", $"""{scheduleItem.PaymentStatus.Html.Replace(" ", "&nbsp;")}"""
                    yield "", $"""{scheduleItem.BalanceStatus.Html.Replace(" ", "&nbsp;")}"""
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "", $"""{Array.toStringOrNa scheduleItem.NewCharges |> _.Replace(" ", "&nbsp;")}"""
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.ChargesPortion}"
                    yield "", $"{formatDecimalCent scheduleItem.ActuarialInterest}"
                    yield "", $"{formatDecimalCent scheduleItem.NewInterest}"
                    yield "", $"{formatCent scheduleItem.InterestPortion}"
                    if p.Basic.FeeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.FeeRebateIfSettled}"
                    if p.Basic.FeeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.FeeRebate}"
                    if p.Basic.FeeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.FeePortion}"
                    yield "", $"{formatCent scheduleItem.PrincipalPortion}"
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.ChargesBalance}"
                    yield "", $"{formatDecimalCent scheduleItem.InterestBalance}"
                    if p.Basic.FeeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.FeeBalance}"
                    yield "", $"{formatCent scheduleItem.PrincipalBalance}"
                    yield "", $"{formatCent scheduleItem.SettlementFigure}"
                |]
                |> Array.mapi (fun i (style, content) ->
                    $"""
        <td class="ci{i:``00``}"{style}>{content}</td>"""
                )
                |> String.concat ""

            $"""
    <tr style="text-align: right;">{fields}
    </tr>"""


    /// a container for aggregating figures separately from the main schedule
    [<Struct>]
    type Accumulator = {
        /// the total of scheduled payments up to the current day
        CumulativeScheduledPayments: int64<Cent>
        /// the total of actual payments made up to the current day
        CumulativeActualPayments: int64<Cent>
        /// the total of generated payments made up to the current day
        CumulativeGeneratedPayments: int64<Cent>
        /// the total fee paid up to the current day
        CumulativeFee: int64<Cent>
        /// the total of interest accrued up to the current day
        CumulativeInterest: decimal<Cent>
        /// the total of interest portions up to the current day
        CumulativeInterestPortions: int64<Cent>
        /// the total of actuarial interest accrued up to the current day
        CumulativeActuarialInterestM: decimal<Cent>
    }

    /// final statistics resulting from the calculations
    [<Struct>]
    type FinalStats = {
        /// the final number of scheduled payments in the schedule
        RequiredScheduledPaymentCount: int
        /// the offset day of the final required scheduled payment
        LastRequiredScheduledPaymentDay: int<OffsetDay> voption
        /// the final number of actual payments in the schedule (multiple payments made on the same day are counted separately)
        FinalActualPaymentCount: int
        /// the offset day of the final actual payment
        LastActualPaymentDay: int<OffsetDay> voption
        /// the final ratio of (fee + interest + charges) to principal
        FinalCostToBorrowingRatio: Percent
        /// the daily interest rate derived from interest over (principal + fee), ignoring charges
        EffectiveInterestRate: Interest.Rate
        /// the generated settlement figure from the schedule
        SettlementFigure: (int<OffsetDay> * int64<Cent>) voption
        /// the final balance status of the schedule
        FinalBalanceStatus: BalanceStatus
    }

    /// final statistics resulting from the calculations
    module FinalStats =
        /// formats the schedule stats as an HTML table (excluding the items, which are rendered separately)
        let toHtmlTable finalStats =
            $"""
<table>
    <tr>
        <td>Generated settlement: <i>{finalStats.SettlementFigure
                                      |> function
                                          | ValueSome(d, gv) -> $"{formatCent gv} on day {d}"
                                          | ValueNone -> "<i>n/a</i>"}</i></td>
        <td>Final balance status: <i>{finalStats.FinalBalanceStatus}</i></td>
    </tr>
    <tr>
        <td>Effective interest rate: <i>{finalStats.EffectiveInterestRate}</i></td>
        <td>Final cost-to-borrowing ratio: <i>{finalStats.FinalCostToBorrowingRatio}</i></td>
    </tr>
    <tr>
        <td>Required scheduled payment count: <i>{finalStats.RequiredScheduledPaymentCount}</i></td>
        <td>Last required scheduled payment day: <i>{finalStats.LastRequiredScheduledPaymentDay
                                                     |> ValueOption.map string
                                                     |> ValueOption.defaultValue "n/a"}</i></td>
    </tr>
    <tr>
        <td>Final actual payment count: <i>{finalStats.FinalActualPaymentCount}</i></td>
        <td>Last actual payment day: <i>{finalStats.LastActualPaymentDay
                                         |> ValueOption.map string
                                         |> ValueOption.defaultValue "n/a"}</i></td>
    </tr>
</table>
"""

    /// a schedule showing the amortisation, itemising the effects of payments and calculating balances for each item, and producing some final statistics resulting from the calculations
    [<Struct>]
    type Schedule = {
        /// a list of amortisation items, showing the events and calculations for a particular offset day
        ScheduleItems: Map<int<OffsetDay>, ScheduleItem>
        /// final stats resulting from the calculations
        FinalStats: FinalStats
    }

    /// results of the amortisation schedule generation
    type GenerationResult = {
        AmortisationSchedule: Schedule
        BasicSchedule: BasicSchedule
    }

    /// a schedule showing the amortisation, itemising the effects of payments and calculating balances for each item, and producing some final statistics resulting from the calculations
    module Schedule =
        /// formats the schedule items as an HTML table (stats can be rendered separately)
        let toHtmlTable (p: Parameters) schedule =
            let fieldHeaders =
                [|
                    yield "Day"
                    yield "Datestamp"
                    yield "Advances"
                    yield "Scheduled payment"
                    yield "Window"
                    yield "Payment due"
                    yield "Actual payments"
                    yield "Paid by"
                    if not p.Advanced.SettlementDay.IsNoSettlement then
                        yield "Generated payment"
                    yield "Net effect"
                    yield "Payment status"
                    yield "Balance status"
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "New charges"
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "Charges portion"
                    yield "Actuarial interest"
                    yield "New interest"
                    yield "Interest portion"
                    if p.Basic.FeeConfig.IsSome then
                        yield "Fee rebate if&nbsp;settled"
                    if p.Basic.FeeConfig.IsSome then
                        yield "Fee rebate"
                    if p.Basic.FeeConfig.IsSome then
                        yield "Fee portion"
                    yield "Principal portion"
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "Charges balance"
                    yield "Interest balance"
                    if p.Basic.FeeConfig.IsSome then
                        yield "Fee balance"
                    yield "Principal balance"
                    yield "Settlement figure"
                |]
                |> Array.mapi (fun i fh ->
                    $"""
        <th class="ci{i:``00``}" style="text-align: right;">{fh}</th>"""
                )
                |> String.concat ""

            $"""
<table>
    <thead style="vertical-align: bottom;">{fieldHeaders}
    </thead>{schedule.ScheduleItems
             |> Map.map (ScheduleItem.toHtmlRow p p.Advanced.SettlementDay)
             |> Map.values
             |> String.concat ""}
</table>"""

        /// renders the schedule as an HTML table within a markup file, which can both be previewed in VS Code and imported as XML into Excel
        let outputHtmlToFile folder title description (p: Parameters) (extraInfo: string) generationResult =
            let htmlTitle = $"<h2>{title}</h2>"

            let htmlSchedule = toHtmlTable p generationResult.AmortisationSchedule

            let htmlKey = "<p>Key: &#x2605; = evaluation day; &#x2713; = settlement day</p>"

            let htmlDescription =
                $"""
<h4>Description</h4>
<p><i>{description}</i></p>"""

            let htmlDatestamp =
                $"""
<p>Generated: <i><a href="../GeneratedDate.html">see details</a></i></p>"""

            let htmlBasicParams =
                $"""
<h4>Basic Parameters</h4>{BasicParameters.toHtmlTable p.Basic}"""

            let htmlAdvancedParams =
                $"""
<h4>Advanced Parameters</h4>{AdvancedParameters.toHtmlTable p.Advanced}"""

            let htmlExtraInfo =
                match extraInfo with
                | "" -> ""
                | ei ->
                    $"""
<h4>Extra Info</h4>{ei}"""

            let originalBasicSchedule = calculateBasicSchedule p.Basic

            let htmlInitialSchedule =
                $"""<h4>Initial Schedule</h4>{BasicSchedule.toHtmlTable originalBasicSchedule}"""

            let htmlInitialStats =
                $"""
<h4>Initial Stats</h4>{InitialStats.toHtmlTable originalBasicSchedule.Stats}"""

            let htmlFinalStats =
                $"""
<h4>Final Stats</h4>{FinalStats.toHtmlTable generationResult.AmortisationSchedule.FinalStats}"""

            let filename = $"out/{folder}/{title}.md"

            $"{htmlTitle}{htmlSchedule}{htmlKey}{htmlFinalStats}{htmlDescription}{htmlDatestamp}{htmlBasicParams}{htmlAdvancedParams}{htmlExtraInfo}{htmlInitialSchedule}{htmlInitialStats}"
            |> outputToFile' filename false

    /// gets the window for the current day based on either the unit-period map or the previous window
    let getWindow unitPeriodMap currentDay currentScheduledPayment previousWindow =
        match unitPeriodMap with
        | Some upm ->
            // use the unit-period map to determine the window for the current day
            upm |> Map.find currentDay
        | None ->
            // determine the window and increment every time a new scheduled payment is due
            if ScheduledPayment.isSome currentScheduledPayment then
                previousWindow + 1
            else
                previousWindow

    /// gets an array of advances
    ///
    /// note: assumes single advance on day 0 (multiple advances are not currently supported), so this is based purely on the principal
    let getAdvances currentDay principal =
        if currentDay = 0<OffsetDay> then [| principal |] else [||]

    /// calculates the fee total as a percentage of the principal, for further calculation (weighting payments made when apportioning to fee and principal)
    let feePercentage principal feeTotal =
        if principal = 0L<Cent> then
            Percent 0m
        else
            decimal feeTotal / decimal principal |> Percent.fromDecimal

    /// gets the balance status based on the principal balance
    let getBalanceStatus principalBalance previousBalanceStatus =
        if principalBalance = 0L<Cent> then
            ClosedBalance
        elif principalBalance < 0L<Cent> then
            RefundDue
        elif principalBalance > 0L<Cent> && previousBalanceStatus = RefundDue then
            OverRefunded
        else
            OpenBalance

    /// determines whether a schedule is settled within any grace period (e.g. no interest may be due if settlement is made within three days of the advance)
    let isSettledWithinGracePeriod (p: Parameters) =
        match p.Advanced.SettlementDay with
        | SettlementDay.SettlementOnEvaluationDay ->
            int <| OffsetDay.fromDate p.Basic.StartDate p.Basic.EvaluationDate
            <= int p.Advanced.InterestConfig.InitialGracePeriod
        | SettlementDay.NoSettlement -> false

    /// pattern matching for payments due vs payments made
    let (|NotPaidAtAll|SomePaid|FullyPaid|) (actualPaymentTotal, paymentDueTotal) =
        if actualPaymentTotal = 0L<Cent> then
            NotPaidAtAll
        elif actualPaymentTotal < paymentDueTotal then
            SomePaid(paymentDueTotal - actualPaymentTotal)
        else
            FullyPaid

    /// calculates the total fee payable up to a particular day, based on a proportion of days elapsed vs total number of days in the original schedule
    let calculateFee feeTotal appliedPaymentDay originalFinalPaymentDay =
        if originalFinalPaymentDay <= 0<OffsetDay> then
            0L<Cent>
        elif appliedPaymentDay > originalFinalPaymentDay then
            0L<Cent>
        else
            decimal feeTotal * (decimal originalFinalPaymentDay - decimal appliedPaymentDay)
            / decimal originalFinalPaymentDay
            |> Cent.round RoundUp
            |> max 0L<Cent>

    /// determines any payment due on the day
    let calculatePaymentDue si originalPayment rescheduledPayment extraPaymentsBalance interestPortionL minimumPayment =
        // if the balance is not open, no payment is due
        if si.BalanceStatus <> OpenBalance then
            0L<Cent>
        // otherwise, calculate the payment due based on scheduled payments and various balances
        else
            match originalPayment, rescheduledPayment with
            // always make rescheduled payment value due in full
            | _, ValueSome rp -> rp.Value
            // if the original payment is cancelled due to rescheduling, there nothing is due
            | ValueSome op, _ when op = 0L<Cent> -> 0L<Cent>
            // reduce the payment due if early/extra payments have been made
            | ValueSome op, _ when extraPaymentsBalance > 0L<Cent> -> op - extraPaymentsBalance
            // non-zero original payments are due in full
            | ValueSome op, _ -> op
            // if there are no original or rescheduled payments on the day, there is nothing due to pay
            | ValueNone, ValueNone -> 0L<Cent>
            // payment due should never exceed settlement figure
            |> min (si.PrincipalBalance + si.FeeBalance + interestPortionL)
            // payment due should never be negative
            |> max 0L<Cent>
            // apply minimum payment rules
            |> fun payment ->
                match minimumPayment with
                | NoMinimumPayment -> payment
                | DeferOrWriteOff minimumPayment when payment < minimumPayment -> 0L<Cent>
                | ApplyMinimumPayment minimumPayment when payment < minimumPayment -> payment
                | _ -> payment

    /// for UK FCA-regulated agreements, calculates the fee rebate due
    let calculateStatutoryFeeRebate
        bp
        (appliedPayments: Map<int<OffsetDay>, AppliedPayment>)
        initialStats
        appliedPaymentDay
        window
        =
        let originalScheduledPayments =
            appliedPayments
            |> Map.filter (fun _ ap -> ap.ScheduledPayment.Original.IsSome)
            |> Map.toArray
            |> Array.mapi (fun i (d, ap) -> {|
                Window = i
                OffsetDay = d
                OriginalScheduledPaymentValue = ap.ScheduledPayment.Original.Value
            |})

        let unitPeriod =
            match bp.ScheduleConfig with
            | AutoGenerateSchedule ags -> UnitPeriod.Config.unitPeriod ags.UnitPeriodConfig
            | FixedSchedules _
            | CustomSchedule _ ->
                let finalScheduledPaymentDate =
                    initialStats.LastScheduledPaymentDay |> OffsetDay.toDate bp.StartDate

                let transactionTerm =
                    UnitPeriod.transactionTerm bp.StartDate bp.StartDate finalScheduledPaymentDate bp.StartDate

                let paymentDates =
                    originalScheduledPayments
                    |> Array.map (_.OffsetDay >> OffsetDay.toDate bp.StartDate)

                UnitPeriod.nearest transactionTerm [| bp.StartDate |] paymentDates

        let previousScheduledPaymentDate =
            originalScheduledPayments
            |> Array.filter (fun osp -> osp.OffsetDay <= appliedPaymentDay)
            |> Array.last
            |> _.OffsetDay

        let numerator = appliedPaymentDay - previousScheduledPaymentDate |> int
        let denominator = UnitPeriod.roughLength unitPeriod
        let settlementPartPeriod = Fraction.Simple(numerator, denominator)

        let payments =
            originalScheduledPayments
            |> Array.map (fun osp -> osp.Window, osp.OriginalScheduledPaymentValue)

        Interest.calculateRebate
            bp.Principal
            payments
            initialStats.InitialApr
            window
            settlementPartPeriod
            unitPeriod
            bp.PaymentConfig.Rounding

    // gets an array of daily interest rates for a given date range, taking into account grace periods and promotional rates
    let getDailyInterestRates (p: Parameters) fromDay toDay =
        Interest.dailyRates
            p.Basic.StartDate
            (isSettledWithinGracePeriod p)
            p.Basic.InterestConfig.StandardRate
            p.Advanced.InterestConfig.PromotionalRates
            fromDay
            toDay

    /// calculates actuarial interest between two days
    let calculateActuarialInterest
        (p: Parameters)
        (previous: ScheduleItem)
        (previousDay: int<OffsetDay>)
        (currentDay: int<OffsetDay>)
        (interestRounding: Rounding)
        =
        let dailyInterestRates = getDailyInterestRates p previousDay currentDay

        if previous.BalanceStatus = OverRefunded then
            0m<Cent>
        elif previous.PrincipalBalance <= 0L<Cent> then
            dailyInterestRates
            |> Array.map (fun dr -> {
                dr with
                    InterestRate = p.Advanced.InterestConfig.RateOnNegativeBalance
            })
            |> Interest.calculate (previous.PrincipalBalance + previous.FeeBalance) Amount.Unlimited interestRounding
        else
            dailyInterestRates
            |> Interest.calculate
                (previous.PrincipalBalance + previous.FeeBalance)
                p.Basic.InterestConfig.Cap.DailyAmount
                interestRounding

    /// calculates new interest based on the interest method
    let calculateNewInterest
        interestMethod
        previousBalanceStatus
        cumulativeActuarialInterestM
        cappedActuarialInterestM
        initialInterestBalanceM
        actuarialInterestM //this can be higher than the capped actuarial interest because it can include an adjustment that sucks in all the lost interest from rounding
        =
        match previousBalanceStatus, interestMethod with
        | _, Interest.Method.Actuarial -> actuarialInterestM
        | ClosedBalance, _
        | OverRefunded, _ -> 0m<Cent>
        | _ ->
            cumulativeActuarialInterestM + cappedActuarialInterestM
            |> fun i ->
                if i > initialInterestBalanceM then
                    i - initialInterestBalanceM
                else
                    0m<Cent>
            |> min cappedActuarialInterestM

    /// ignores small amounts of interest that have accumulated by the last day of the schedule, with the allowance being proportional to the length of the schedule
    let calculateFinalInterestReduction
        (currentDay: int<OffsetDay>)
        maxAppliedPaymentDay
        appliedPaymentCount
        interestM
        =
        if interestM > 0m<Cent> && currentDay = maxAppliedPaymentDay then
            interestM - Interest.ignoreFractionalCents appliedPaymentCount interestM
        else
            0m<Cent>

    /// calculates any new interest accrued since the previous item, according to the interest method supplied in the schedule parameters
    let calculateInterestAdjustment
        previousBalanceStatus
        currentGeneratedPayment
        settlement
        cappedNewInterestM
        cumulativeActuarialInterestM
        initialInterestBalanceM
        (basicParameters: BasicParameters)
        =
        match basicParameters.InterestConfig.Method with
        | Interest.Method.AddOn when
            previousBalanceStatus <> ClosedBalance
            && (currentGeneratedPayment = ToBeGenerated || settlement <= 0L<Cent>)
            && previousBalanceStatus <> RefundDue
            && previousBalanceStatus <> OverRefunded
            && cappedNewInterestM = 0m<Cent>  // cappedNewInterest check here avoids adding an interest adjustment twice (one for generated payment, one for final payment)
            ->
            cumulativeActuarialInterestM - initialInterestBalanceM
            |> Interest.ignoreFractionalCents 1u
            |> Interest.Cap.cappedAddedValue
                basicParameters.InterestConfig.Cap.TotalAmount
                basicParameters.Principal
                cumulativeActuarialInterestM
        | _ -> 0m<Cent>

    /// apportions the interest
    let apportionInterest madePaymentTotal previousSettlementFigure cappedNewInterestM previousInterestBalance =
        // if a refund is made and the settlement figure is postive, the payment should be apportioned to principal rather than interest (this likely represents a goodwill gesture so should directly benefit the customer)
        if madePaymentTotal < 0L<Cent> && previousSettlementFigure >= 0L<Cent> then
            0m<Cent>
        // otherwise, add new interest to the interest balance as normal
        else
            cappedNewInterestM + previousInterestBalance

    /// apportions the fee
    let apportionFee (basicFeeConfig: Fee.BasicConfig voption) previousFeeBalance assignable principal feeTotal =
        match basicFeeConfig with
        | ValueSome feeConfig ->
            match feeConfig.FeeAmortisation with
            | Fee.FeeAmortisation.AmortiseBeforePrincipal -> min previousFeeBalance assignable
            | Fee.FeeAmortisation.AmortiseProportionately ->
                feePercentage principal feeTotal
                |> Percent.toDecimal
                |> fun m ->
                    if 1m + m = 0m then
                        0L<Cent>
                    else
                        decimal assignable * m / (1m + m)
                        |> Cent.round RoundUp
                        |> max 0L<Cent>
                        |> min previousFeeBalance
        | ValueNone -> 0L<Cent>

    /// determines the value of any fee rebate in the event of settlement, depending on settings
    let calculateFeeRebate
        (advancedFeeConfig: Fee.AdvancedConfig voption)
        scheduleConfig
        startDate
        feeTotal
        currentDay
        cumulativeFee
        =
        match advancedFeeConfig with
        | ValueSome feeConfig ->
            match feeConfig.SettlementRebate with
            | Fee.SettlementRebate.ProRata ->
                let originalFinalPaymentDay =
                    scheduleConfig
                    |> generatePaymentMap startDate
                    |> Map.keys
                    |> Seq.toArray
                    |> Array.tryLast
                    |> Option.defaultValue 0<OffsetDay>

                calculateFee feeTotal currentDay originalFinalPaymentDay
            | Fee.SettlementRebate.ProRataRescheduled originalFinalPaymentDay ->
                calculateFee feeTotal currentDay originalFinalPaymentDay
            | Fee.SettlementRebate.Balance -> cumulativeFee
            | Fee.SettlementRebate.Zero -> 0L<Cent>
        | ValueNone -> 0L<Cent>

    let createInitialScheduleItem startDate principal fee interest (advancedFeeConfig: Fee.AdvancedConfig voption) = {
        ScheduleItem.zero with
            OffsetDate = startDate
            Advances = [| principal |]
            PrincipalBalance = principal
            FeeBalance = fee
            InterestBalance = interest
            SettlementFigure = principal + fee
            FeeRebateIfSettled =
                match advancedFeeConfig with
                | ValueSome fc ->
                    match fc.SettlementRebate with
                    | Fee.SettlementRebate.Zero -> 0L<Cent>
                    | _ -> fee
                | ValueNone -> 0L<Cent>
    }

    let createInitialTotals interest = {
        CumulativeScheduledPayments = 0L<Cent>
        CumulativeActualPayments = 0L<Cent>
        CumulativeGeneratedPayments = 0L<Cent>
        CumulativeFee = 0L<Cent>
        CumulativeInterest = interest
        CumulativeInterestPortions = 0L<Cent>
        CumulativeActuarialInterestM = 0m<Cent>
    }

    // removes duplicated initial offset day
    let deduplicateDay0 (a: (int<OffsetDay> * ScheduleItem) array) =
        if a |> Array.filter (fun (day, _) -> day = 0<OffsetDay>) |> Array.length = 2 then
            a |> Array.tail
        else
            a

    /// get the unit period and project it over the schedule to determine the amortisation windows
    let mapUnitPeriods scheduleConfig startDate maxAppliedPaymentDay =
        match scheduleConfig with
        | AutoGenerateSchedule ags ->
            let paymentSchedule =
                UnitPeriod.generatePaymentSchedule
                    (UnitPeriod.ScheduleLength.MaxDuration(startDate, int maxAppliedPaymentDay * 1<DurationDay>))
                    UnitPeriod.Direction.Forward
                    ags.UnitPeriodConfig
                |> Array.insertAt 0 startDate
                |> Array.indexed

            let dayToUnitPeriodMap =
                [| 0 .. int maxAppliedPaymentDay |]
                |> Array.map (fun day ->
                    let day = day * 1<OffsetDay>
                    let date = OffsetDay.toDate startDate day

                    let unitPeriodIndex =
                        paymentSchedule
                        |> Array.filter (fun (_, paymentDate) -> paymentDate <= date)
                        |> Array.tryLast
                        |> Option.map fst
                        |> Option.defaultValue 0

                    day, unitPeriodIndex
                )
                |> Map.ofArray

            Some dayToUnitPeriodMap
        | _ -> None

    /// calculates an amortisation schedule detailing how elements (principal, fee, interest and charges) are paid off over time
    let internal calculate (p: Parameters) initialStats (appliedPayments: Map<int<OffsetDay>, AppliedPayment>) =

        let evaluationDay = (p.Basic.EvaluationDate - p.Basic.StartDate).Days * 1<OffsetDay>

        // get the decimal initial interest balance (interest is generally calculated as a decimal until concretised as an interest portion, at which point it is rounded to an integer)
        let initialInterestBalanceM = Cent.toDecimalCent initialStats.InitialInterestBalance

        let feeTotal = Fee.total p.Basic.FeeConfig p.Basic.Principal

        let interestRounding = p.Basic.InterestConfig.Rounding

        // get stats for interest rounding at the end of the schedule
        let maxAppliedPaymentDay = appliedPayments |> Map.keys |> Seq.max
        let appliedPaymentCount = appliedPayments |> Map.count |> uint

        let unitPeriodMap =
            mapUnitPeriods p.Basic.ScheduleConfig p.Basic.StartDate maxAppliedPaymentDay

        /// generates the amortisation schedule
        let generator ((previousDay, previous), totals) (currentDay, current: AppliedPayment) =

            let window =
                getWindow unitPeriodMap currentDay current.ScheduledPayment previous.Window

            let advances = getAdvances currentDay p.Basic.Principal

            let actuarialInterestM =
                calculateActuarialInterest p previous previousDay currentDay interestRounding

            let madePaymentTotal =
                current.ActualPayments |> Map.values |> Seq.sumBy ActualPayment.totalMade

            let cappedActuarialInterestM =
                Interest.Cap.cappedAddedValue
                    p.Basic.InterestConfig.Cap.TotalAmount
                    p.Basic.Principal
                    totals.CumulativeActuarialInterestM
                    actuarialInterestM

            let newInterestM =
                calculateNewInterest
                    p.Basic.InterestConfig.Method
                    previous.BalanceStatus
                    totals.CumulativeActuarialInterestM
                    cappedActuarialInterestM
                    initialInterestBalanceM
                    actuarialInterestM

            let cappedNewInterestM, finalInterestReductionM =
                let cni =
                    Interest.Cap.cappedAddedValue
                        p.Basic.InterestConfig.Cap.TotalAmount
                        p.Basic.Principal
                        totals.CumulativeInterest
                        newInterestM

                let fir =
                    calculateFinalInterestReduction currentDay maxAppliedPaymentDay appliedPaymentCount cni

                cni - fir, fir

            let finalInterestReductionL =
                finalInterestReductionM |> Cent.fromDecimalCent interestRounding

            let pendingPaymentTotal =
                current.ActualPayments |> Map.values |> Seq.sumBy ActualPayment.totalPending

            let interestPortionM =
                apportionInterest madePaymentTotal previous.SettlementFigure cappedNewInterestM previous.InterestBalance

            let interestPortionL = interestPortionM |> Cent.fromDecimalCent interestRounding

            let totals' = {
                totals with
                    CumulativeActuarialInterestM = totals.CumulativeActuarialInterestM + cappedActuarialInterestM
                    CumulativeScheduledPayments =
                        totals.CumulativeScheduledPayments
                        + ScheduledPayment.total current.ScheduledPayment
                    CumulativeActualPayments = totals.CumulativeActualPayments + madePaymentTotal + pendingPaymentTotal
                    CumulativeInterest = totals.CumulativeInterest + cappedNewInterestM
            }

            let extraPaymentsBalance =
                totals.CumulativeActualPayments
                - totals.CumulativeScheduledPayments
                - totals.CumulativeGeneratedPayments

            let paymentDue =
                calculatePaymentDue
                    previous
                    current.ScheduledPayment.Original
                    current.ScheduledPayment.Rescheduled
                    extraPaymentsBalance
                    interestPortionL
                    p.Advanced.PaymentConfig.Minimum

            let newChargesTotal, incurredCharges =
                if paymentDue = 0L<Cent> then
                    0L<Cent>, [||]
                else
                    current.AppliedCharges |> Array.sumBy _.Total, current.AppliedCharges

            let chargesPortion = newChargesTotal + previous.ChargesBalance |> max 0L<Cent>

            // for future days, assume that the payment will be made in full and on schedule, yielding a full net effect and allowing meaningful evaluation of the future schedule
            // (e.g. seeing if the schedule will be settled as agreed)
            let netEffect =
                if currentDay > evaluationDay then
                    min current.NetEffect paymentDue
                else
                    current.NetEffect

            // simplifies any refund apportionment by modifying the sign of certain values depending on whether the net effect is positive or negative
            let sign: int64<Cent> -> int64<Cent> = if netEffect < 0L<Cent> then (*) -1L else id

            let cumulativeActuarialInterestL =
                totals'.CumulativeActuarialInterestM |> Cent.fromDecimalCent interestRounding

            let settlement, principalForgiven =
                p.Basic.Principal + cumulativeActuarialInterestL
                - totals'.CumulativeActualPayments
                |> fun s ->
                    if abs s < int64 appliedPaymentCount * 1L<Cent> then
                        0L<Cent>, s
                    else
                        s, 0L<Cent>

            // get a settlement figure for the add-on interest method based on the actual actuarial interest accrued up to now
            let generatedSettlementPayment =
                match p.Basic.InterestConfig.Method with
                | Interest.Method.AddOn when previous.BalanceStatus <> ClosedBalance ->
                    settlement - finalInterestReductionL
                | _ -> 0L<Cent>

            // determine whether an interest adjustment is required based on the difference between cumulative actuarial interest and the initial interest balance
            let interestAdjustmentM =
                calculateInterestAdjustment
                    previous.BalanceStatus
                    current.GeneratedPayment
                    settlement
                    cappedNewInterestM
                    totals'.CumulativeActuarialInterestM
                    initialInterestBalanceM
                    p.Basic

            // refine the capped new interest value using any interest adjustment
            let cappedNewInterestM' = cappedNewInterestM + interestAdjustmentM

            // get the rounded value of the interest adjustment
            let interestAdjustmentL =
                interestAdjustmentM |> Cent.fromDecimalCent interestRounding

            // refine the interest portion based on any interest adjustment, and again check against the total interest cap
            let interestPortionL' =
                interestPortionL + interestAdjustmentL
                |> Cent.toDecimalCent
                |> Interest.Cap.cappedAddedValue
                    p.Basic.InterestConfig.Cap.TotalAmount
                    p.Basic.Principal
                    (Cent.toDecimalCent totals.CumulativeInterestPortions)
                |> Cent.fromDecimalCent interestRounding

            // determine how much of the net effect can be apportioned and whether any immediate adjustments need to be made to the scheduled payment due to charges and interest, depending on settings
            let assignable, scheduledPaymentAdjustment =
                if netEffect = 0L<Cent> then
                    0L<Cent>, 0L<Cent>
                else
                    match p.Advanced.PaymentConfig.ScheduledPaymentOption with
                    | AsScheduled -> sign netEffect - sign chargesPortion - sign interestPortionL', 0L<Cent>
                    | AddChargesAndInterest -> sign netEffect, sign chargesPortion - sign interestPortionL'

            let scheduledPayment = {
                current.ScheduledPayment with
                    Adjustment = scheduledPaymentAdjustment
            }


            let feePortion =
                apportionFee p.Basic.FeeConfig previous.FeeBalance assignable p.Basic.Principal feeTotal

            let feeRebateIfSettled =
                calculateFeeRebate
                    p.Advanced.FeeConfig
                    p.Basic.ScheduleConfig
                    p.Basic.StartDate
                    feeTotal
                    currentDay
                    totals'.CumulativeFee

            // refine the settlement figure depending on the interest method
            let generatedSettlementPayment' =
                match p.Basic.InterestConfig.Method with
                | Interest.Method.AddOn -> generatedSettlementPayment
                | _ ->
                    previous.PrincipalBalance + previous.FeeBalance - feeRebateIfSettled
                    + interestPortionL'
                    + chargesPortion

            // refine the fee portion and rebate if a rebate is actually applied on the day, i.e. if the net effect covers the settlement figure
            let feePortion', feeRebate =
                if
                    current.GeneratedPayment.IsToBeGenerated
                    || feePortion > 0L<Cent> && generatedSettlementPayment' <= netEffect
                then
                    let feeRebate' =
                        match p.Basic.InterestConfig.AprMethod with
                        | Apr.CalculationMethod.UnitedKingdom _ when feeRebateIfSettled > 0L<Cent> ->
                            // if the statutory rebate is higher than the fee rebate calculated above, use the higher figure
                            calculateStatutoryFeeRebate p.Basic appliedPayments initialStats currentDay window
                            |> max feeRebateIfSettled
                            |> min feeTotal
                        | _ -> feeRebateIfSettled

                    max 0L<Cent> (previous.FeeBalance - feeRebate'), feeRebate'
                else
                    sign feePortion, 0L<Cent>

            // apportion the principal
            let principalPortion = max 0L<Cent> (assignable - feePortion')

            // calculate the principal balance
            let principalBalance = previous.PrincipalBalance - sign principalPortion

            // if any future payment creates a negative principal balance, adjust these figures accordingly
            let paymentDue', netEffect', principalPortion', principalBalance' =
                if
                    current.PaymentStatus = NotYetDue
                    && feeRebate > 0L<Cent>
                    && principalBalance < 0L<Cent>
                then
                    paymentDue + principalBalance,
                    netEffect + principalBalance,
                    sign principalPortion + principalBalance,
                    0L<Cent>
                else
                    paymentDue, netEffect, sign principalPortion, principalBalance

            // if any charges or interest are not fully covered by the actual payment total, determine the values to carry over to the next item
            let carriedCharges, carriedInterestL =
                if sign chargesPortion > sign netEffect then
                    chargesPortion - netEffect, interestPortionL
                elif netEffect = 0L<Cent> && interestPortionM < 0m<Cent> then
                    0L<Cent>, interestPortionL
                elif sign chargesPortion + sign interestPortionL' > sign netEffect then
                    0L<Cent>, interestPortionL - (netEffect - chargesPortion)
                else
                    0L<Cent>, 0L<Cent>

            // get the date equivalent of the offset day for further calculation
            let offsetDate = p.Basic.StartDate.AddDays(int currentDay)

            // determine the principal balance
            let balanceStatus = getBalanceStatus principalBalance' previous.BalanceStatus

            // calculate the interest balance as a decimal
            let interestBalanceM =
                previous.InterestBalance + cappedNewInterestM'
                - Cent.toDecimalCent (interestPortionL' - carriedInterestL)

            // get the rounded interest balance
            let interestBalanceL = interestBalanceM |> decimal |> Cent.round interestRounding

            // creates an item that optionally creates a settlement
            let createScheduleItem isSettlement =
                // refine the payment status based on the balance status and whether this is a settlement
                let paymentStatus =
                    match current.PaymentStatus, previous.BalanceStatus, isSettlement with
                    | InformationOnly, _, _ -> InformationOnly
                    | _, ClosedBalance, _ -> NoLongerRequired
                    | _, _, true -> Generated
                    | _, RefundDue, _ when netEffect' < 0L<Cent> -> Refunded
                    | _, RefundDue, _ when netEffect' > 0L<Cent> -> Overpayment
                    | _, RefundDue, _ -> NoLongerRequired
                    | _ when
                        paymentDue' = 0L<Cent>
                        && madePaymentTotal = 0L<Cent>
                        && pendingPaymentTotal = 0L<Cent>
                        && GeneratedPayment.total current.GeneratedPayment = 0L<Cent>
                        ->
                        NothingDue
                    | _ -> current.PaymentStatus

                // refine the settlement figure if necessary by subtracting any payment made on the same day, or nullifying it if there are payments pending (settlement cannot be made in this case)
                let settlementFigure =
                    match
                        previous.BalanceStatus,
                        pendingPaymentTotal,
                        current.PaymentStatus,
                        p.Basic.InterestConfig.Method
                    with
                    | OverRefunded, _, _, _ -> previous.PrincipalBalance
                    | _, pp, _, _ when pp > 0L<Cent> -> 0L<Cent>
                    | _, _, NotYetDue, _
                    | _, _, _, Interest.Method.AddOn -> generatedSettlementPayment'
                    | _ -> generatedSettlementPayment' - netEffect'

                // deteremine the settlement balances or carried balances
                let balances, interestPortionL', generatedPayment =
                    if isSettlement then
                        // convert the generated payment placeholder with an actual settlement figure
                        (0L<Cent>, 0L<Cent>, 0m<Cent>, 0L<Cent>),
                        interestPortionL',
                        match current.GeneratedPayment with
                        | ToBeGenerated -> GeneratedValue settlementFigure
                        | gp -> gp
                    else
                        // refine the interest portion by adding carried interest, and calculate the balances
                        let feeBalance = previous.FeeBalance - feePortion' - feeRebate
                        let interestBalance = interestBalanceM |> Interest.ignoreFractionalCents 1u

                        let chargesBalance =
                            previous.ChargesBalance + newChargesTotal - chargesPortion + carriedCharges

                        (principalBalance', feeBalance, interestBalance, chargesBalance),
                        interestPortionL' - carriedInterestL,
                        current.GeneratedPayment

                // assign the separate balances
                let principalBal, feeBal, interestBal, chargesBal = balances

                // ensure the settlement figure is never more than the total balances
                let balanceTotal =
                    principalBal
                    + feeBal
                    + Cent.fromDecimalCent p.Basic.InterestConfig.Rounding interestBal
                    + chargesBal

                let settlementFigure' =
                    (balanceTotal, settlementFigure)
                    ||> if settlementFigure < 0L<Cent> then max else min

                //determine the type of offset day
                let offsetDayType =
                    if isSettlement then SettlementDay
                    elif currentDay = evaluationDay then EvaluationDay
                    else OffsetDay

                // create the schedule item
                let scheduleItem = {
                    OffsetDayType = offsetDayType
                    OffsetDate = offsetDate
                    Advances = advances
                    ScheduledPayment = scheduledPayment
                    Window = window
                    PaymentDue = paymentDue'
                    ActualPayments = current.ActualPayments
                    PaidBy = current.PaidBy
                    GeneratedPayment = generatedPayment
                    NetEffect =
                        if isSettlement then
                            netEffect + GeneratedPayment.total generatedPayment
                        else
                            netEffect'
                    PaymentStatus = paymentStatus
                    BalanceStatus = if isSettlement then ClosedBalance else balanceStatus
                    ActuarialInterest = cappedActuarialInterestM
                    NewInterest = cappedNewInterestM'
                    NewCharges = incurredCharges
                    PrincipalPortion =
                        if isSettlement then
                            previous.PrincipalBalance
                        else
                            principalPortion'
                    FeePortion =
                        if isSettlement then
                            previous.FeeBalance - feeRebate
                        else
                            feePortion'
                    InterestPortion = interestPortionL'
                    ChargesPortion =
                        if isSettlement then
                            chargesPortion
                        else
                            chargesPortion - carriedCharges
                    FeeRebate = feeRebate
                    PrincipalBalance = principalBal
                    FeeBalance = feeBal
                    InterestBalance = interestBal
                    ChargesBalance = chargesBal
                    SettlementFigure = settlementFigure'
                    FeeRebateIfSettled =
                        if not isSettlement && paymentStatus = NoLongerRequired then
                            0L<Cent>
                        else
                            feeRebateIfSettled
                }

                // calculate the rounding difference between the decimal and integer interest balances
                let interestRoundingDifferenceM =
                    if not isSettlement && interestPortionL' = 0L<Cent> then
                        0m<Cent>
                    else
                        interestBalanceM - Cent.toDecimalCent interestBalanceL

                // returns the offset day, schedule item, generated payment, and interest rounding difference (zero in this case as it is already factored into the settlement figure)
                currentDay,
                scheduleItem,
                (if isSettlement then settlementFigure' else 0L<Cent>),
                interestRoundingDifferenceM

            // get the relevant type of item based on the intended purpose
            let offsetDay, scheduleItem, generatedPayment, interestRoundingDifferenceM =
                match current.GeneratedPayment, p.Advanced.SettlementDay with
                | ToBeGenerated, SettlementDay.SettlementOnEvaluationDay when evaluationDay = currentDay ->
                    createScheduleItem true
                | GeneratedValue gv, _ -> failwith $"Unexpected value: <i>{gv}</i>"
                | NoGeneratedPayment, _
                | ToBeGenerated, SettlementDay.NoSettlement
                | ToBeGenerated, SettlementDay.SettlementOnEvaluationDay -> createScheduleItem false

            // refine the accumulator values
            let totals'' = {
                totals' with
                    CumulativeScheduledPayments = totals'.CumulativeScheduledPayments + scheduledPaymentAdjustment
                    CumulativeGeneratedPayments = totals.CumulativeGeneratedPayments + generatedPayment
                    CumulativeFee = totals.CumulativeFee + feePortion'
                    CumulativeInterest = totals'.CumulativeInterest - interestRoundingDifferenceM
                    CumulativeInterestPortions = totals.CumulativeInterestPortions + scheduleItem.InterestPortion
            }
            // return the values for the next scan iteration
            (offsetDay, scheduleItem), totals''

        // return the amortisation schedule
        appliedPayments
        |> Map.toArray
        |> Array.scan
            generator
            (
            // initialise the values for the scan
            (0<OffsetDay>,
             createInitialScheduleItem
                 p.Basic.StartDate
                 p.Basic.Principal
                 feeTotal
                 initialInterestBalanceM
                 p.Advanced.FeeConfig),
            createInitialTotals initialInterestBalanceM)
        // separate and discard the accumulator
        |> Array.unzip
        |> fst
        // handle duplicated initial offset day
        |> deduplicateDay0
        |> Map.ofArray
    // post-process missed payments or underpayments

    /// wraps the amortisation schedule in some statistics, and optionally calculates the final APR (optional because it can be processor-intensive)
    let calculateStats (items: Map<int<OffsetDay>, ScheduleItem>) =
        let finalItemDay, finalItem = items |> Map.maxKeyValue
        let items' = items |> Map.toArray |> Array.map snd
        let principalTotal = items' |> Array.sumBy _.PrincipalPortion
        let feeTotal = items' |> Array.sumBy _.FeePortion
        let interestTotal = items' |> Array.sumBy _.InterestPortion
        let chargesTotal = items' |> Array.sumBy _.ChargesPortion
        let feeRebate = finalItem.FeeRebate
        let finalPaymentDay = finalItemDay

        let requiredScheduledPaymentItems =
            items
            |> Map.filter (fun _ si ->
                ScheduledPayment.isSome si.ScheduledPayment
                && not si.PaymentStatus.IsNoLongerRequired
            )

        let actualPaymentItems =
            items |> Map.filter (fun _ si -> Map.count si.ActualPayments > 0)

        {
            ScheduleItems = items
            FinalStats = {
                RequiredScheduledPaymentCount = requiredScheduledPaymentItems |> Map.count
                LastRequiredScheduledPaymentDay =
                    if Map.count requiredScheduledPaymentItems = 0 then
                        ValueNone
                    else
                        requiredScheduledPaymentItems |> Map.maxKeyValue |> fst |> ValueSome
                FinalActualPaymentCount = items' |> Array.sumBy (fun asi -> Map.count asi.ActualPayments)
                LastActualPaymentDay =
                    if Map.count actualPaymentItems = 0 then
                        ValueNone
                    else
                        actualPaymentItems |> Map.maxKeyValue |> fst |> ValueSome
                FinalCostToBorrowingRatio =
                    if principalTotal = 0L<Cent> then
                        Percent 0m
                    else
                        decimal (feeTotal + interestTotal + chargesTotal) / decimal principalTotal
                        |> Percent.fromDecimal
                        |> Percent.round 2
                EffectiveInterestRate =
                    if
                        finalPaymentDay = 0<OffsetDay>
                        || principalTotal + feeTotal - feeRebate = 0L<Cent>
                    then
                        0m
                    else
                        decimal interestTotal
                        / decimal (principalTotal + feeTotal - feeRebate)
                        / decimal finalPaymentDay
                    |> Percent.fromDecimal
                    |> Interest.Rate.Daily
                SettlementFigure =
                    items
                    |> Map.tryPick (fun d si ->
                        match si.GeneratedPayment with
                        | GeneratedValue gv -> Some(d, gv)
                        | _ -> None
                    )
                    |> toValueOption
                FinalBalanceStatus = items |> Map.maxKeyValue |> snd |> _.BalanceStatus
            }
        }

    /// generates an amortisation schedule and final statistics
    let amortise (p: Parameters) actualPayments =
        let basicSchedule = calculateBasicSchedule p.Basic

        let scheduledPayments =
            basicSchedule.Items
            |> Array.filter (_.ScheduledPayment >> ScheduledPayment.isSome)
            |> Array.map (fun si ->
                si.Day,
                {
                    si.ScheduledPayment with
                        Original = si.ScheduledPayment.Original
                }
            )
            |> Map.ofArray

        let amortisationSchedule =
            scheduledPayments
            |> applyPayments p actualPayments
            |> calculate p basicSchedule.Stats
            |> if p.Advanced.TrimEnd then
                   Map.filter (fun _ si -> si.PaymentStatus <> NoLongerRequired)
               else
                   id
            |> calculateStats

        {
            AmortisationSchedule = amortisationSchedule
            BasicSchedule = basicSchedule
        }
