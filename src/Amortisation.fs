namespace FSharp.Finance.Personal

/// calculating the principal balance over time, taking into account the effects of charges, interest and fees
module Amortisation =

    open AppliedPayment
    open Calculation
    open DateDay
    open Scheduling

    /// the status of the balance on a given offset day
    [<Struct>]
    type BalanceStatus =
        /// the balance has been settled in full
        | ClosedBalance
        /// the balance is open, meaning further payments will be required to settle it
        | OpenBalance
        /// due to an overpayment or a refund of charges, a refund is due
        | RefundDue

    /// a dynamic mapping of applied payments to the offset day of a scheduled payment
    type Allocation = {
        /// the day of the scheduled payment
        ScheduledPaymentDay: int<OffsetDay>
        /// how much is allocated to the specified scheduled payment
        Value: int64<Cent>
    }

    /// amortisation schedule item showing apportionment of payments to principal, fees, interest and charges
    type ScheduleItem = {
        /// the date of amortisation
        OffsetDate: Date
        /// any advance made on the current day, typically the principal on day 0 for a single-advance transaction
        Advances: int64<Cent> array
        /// any payment scheduled on the current day
        ScheduledPayment: ScheduledPayment
        /// the window during which a scheduled payment can be made; if the date is missed, the payment is late, but if the window is missed, the payment is missed
        Window: int
        /// any payment scheduled on the current day
        PaymentDue: int64<Cent>
        /// how much of the scheduled payment is eventually paid
        EventuallyPaid: int64<Cent>
        /// any payments actually made on the current day
        ActualPayments: ActualPayment array
        /// how the actual payments are allocated to the scheduled payments
        Allocations: Allocation array
        /// a payment generated by the system e.g. to calculate a settlement figure
        GeneratedPayment: GeneratedPayment
        /// the net effect of the scheduled and actual payments, or, for future days, what the net effect would be if the scheduled payment was actually made
        NetEffect: int64<Cent>
        /// the status based on the payments and net effect
        PaymentStatus: PaymentStatus
        /// the overall balance status
        BalanceStatus: BalanceStatus
        /// any new charges incurred between the previous amortisation day and the current day
        NewCharges: Charge.ChargeType array
        /// the portion of the net effect assigned to the charges
        ChargesPortion: int64<Cent>
        /// the simple interest initially calculated at the start date
        OriginalSimpleInterest: int64<Cent>
        /// the interest initially calculated according to the interest method at the start date
        ContractualInterest: decimal<Cent>
        /// the simple interest accruable between the previous amortisation day and the current day
        SimpleInterest: decimal<Cent>
        /// the new interest charged between the previous amortisation day and the current day, less any initial interest
        NewInterest: decimal<Cent>
        /// the portion of the net effect assigned to the interest
        InterestPortion: int64<Cent>
        /// any fee refund, on the final amortisation day, if the fees are pro-rated in the event of early settlement
        FeesRefund: int64<Cent>
        /// the portion of the net effect assigned to the fees
        FeesPortion: int64<Cent>
        /// the portion of the net effect assigned to the principal
        PrincipalPortion: int64<Cent>
        /// the charges balance to be carried forward
        ChargesBalance: int64<Cent>
        /// the interest balance to be carried forward
        InterestBalance: decimal<Cent>
        /// the fees balance to be carried forward
        FeesBalance: int64<Cent>
        /// the principal balance to be carried forward
        PrincipalBalance: int64<Cent>
        /// the settlement figure as of the current day
        SettlementFigure: int64<Cent> voption
        /// the pro-rated fees as of the current day
        FeesRefundIfSettled: int64<Cent>
    }
    
    /// amortisation schedule item showing apportionment of payments to principal, fees, interest and charges
    module ScheduleItem =
        let initial = {
            Window = 0
            OffsetDate = Unchecked.defaultof<Date>
            Advances = [||]
            ScheduledPayment = ScheduledPayment.zero
            PaymentDue = 0L<Cent>
            EventuallyPaid = 0L<Cent>
            ActualPayments = [||]
            Allocations = [||]
            GeneratedPayment = NoGeneratedPayment
            NetEffect = 0L<Cent>
            PaymentStatus = NoneScheduled
            BalanceStatus = OpenBalance
            OriginalSimpleInterest = 0L<Cent>
            ContractualInterest = 0m<Cent>
            SimpleInterest = 0m<Cent>
            NewInterest = 0m<Cent>
            NewCharges = [||]
            PrincipalPortion = 0L<Cent>
            FeesPortion = 0L<Cent>
            InterestPortion = 0L<Cent>
            ChargesPortion = 0L<Cent>
            FeesRefund = 0L<Cent>
            PrincipalBalance = 0L<Cent>
            FeesBalance = 0L<Cent>
            InterestBalance = 0m<Cent>
            ChargesBalance = 0L<Cent>
            SettlementFigure = ValueNone
            FeesRefundIfSettled = 0L<Cent>
        }

    /// a container for aggregating figures separately from the main schedule
    [<Struct>]
    type Accumulator = {
        /// the total of scheduled payments up to the current day
        CumulativeScheduledPayments: int64<Cent>
        /// the total of actual payments made up to the current day
        CumulativeActualPayments: int64<Cent>
        /// the total of generated payments made up to the current day
        CumulativeGeneratedPayments: int64<Cent>
        /// the total of fees paid up to the current day
        CumulativeFees: int64<Cent>
        /// the total of interest accrued up to the current day
        CumulativeInterest: decimal<Cent>
        /// the total of interest portions up to the current day
        CumulativeInterestPortions: int64<Cent>
        /// the total of simple interest accrued up to the current day
        CumulativeSimpleInterestM: decimal<Cent>
    }

    /// a schedule showing the amortisation, itemising the effects of payments and calculating balances for each item, and producing some final statistics resulting from the calculations
    [<Struct>]
    type Schedule = {
        /// a list of amortisation items, showing the events and calculations for a particular offset day
        ScheduleItems: Map<int<OffsetDay>, ScheduleItem>
        /// the offset day of the final scheduled payment
        FinalScheduledPaymentDay: int<OffsetDay>
        /// the final number of scheduled payments in the schedule
        FinalScheduledPaymentCount: int
        /// the final number of actual payments in the schedule (multiple payments made on the same day are counted separately)
        FinalActualPaymentCount: int
        /// the APR based on the actual payments made and their timings
        FinalApr: (Solution * Percent voption) voption
        /// the final ratio of (fees + interest + charges) to principal
        FinalCostToBorrowingRatio: Percent
        /// the daily interest rate derived from interest over (principal + fees), ignoring charges 
        EffectiveInterestRate: Interest.Rate
    }

    /// calculate amortisation schedule detailing how elements (principal, fees, interest and charges) are paid off over time
    let internal calculate sp settlementDay (initialInterestBalanceL: int64<Cent>) (appliedPayments: Map<int<OffsetDay>, AppliedPayment>) =
        // get the as-of day (the day the schedule is inspected) based on the as-of date in the schedule parameters
        let asOfDay = (sp.AsOfDate - sp.StartDate).Days * 1<OffsetDay>
        // get the decimal initial interest balance (interest is generally calculated as a decimal until concretised as an interest portion, at which point it is rounded to an integer)
        let initialInterestBalanceM = Cent.toDecimalCent initialInterestBalanceL
        // calculate the maximum interest accruable over the entire schedule due to any interest cap
        let totalInterestCapM = sp.InterestConfig.Cap.TotalAmount |> Interest.Cap.total sp.Principal
        // calculate the total fee value for the entire schedule
        let feesTotal = Fee.grandTotal sp.FeeConfig sp.Principal ValueNone
        // calculate the fees total as a percentage of the principal, for further calculation (weighting payments made when apportioning to fees and principal)
        let feesPercentage =
            if sp.Principal = 0L<Cent> then
                Percent 0m
            else
                decimal feesTotal / decimal sp.Principal |> Percent.fromDecimal
        // gets the balance status based on the principal balance
        let getBalanceStatus principalBalance =
            if principalBalance = 0L<Cent> then
                ClosedBalance
            elif principalBalance < 0L<Cent> then
                RefundDue
            else
                OpenBalance
        // determines whether a schedule is settled within any grace period (e.g. no interest may be due if settlement is made within three days of the advance)
        let isSettledWithinGracePeriod =
            match settlementDay with
            | ValueSome (SettlementDay.SettlementOn day) ->
                int day <= int sp.InterestConfig.InitialGracePeriod
            | ValueSome SettlementDay.SettlementOnAsOfDay ->
                int <| OffsetDay.fromDate sp.StartDate sp.AsOfDate <= int sp.InterestConfig.InitialGracePeriod
            | ValueNone ->
                false
        // gets an array of daily interest rates for a given date range, taking into account grace periods and promotional rates
        let dailyInterestRates fromDay toDay =
            Interest.dailyRates sp.StartDate isSettledWithinGracePeriod sp.InterestConfig.StandardRate sp.InterestConfig.PromotionalRates fromDay toDay
        // pattern matching for payments due vs payments made
        let (|NotPaidAtAll|SomePaid|FullyPaid|) (actualPaymentTotal, paymentDueTotal) =
            if actualPaymentTotal = 0L<Cent> then
                NotPaidAtAll
            elif actualPaymentTotal < paymentDueTotal then
                SomePaid (paymentDueTotal - actualPaymentTotal)
            else
                FullyPaid

        let trackEventuallyPaid (schedule: Map<int<OffsetDay>, ScheduleItem>) =
            let scheduleArray = schedule |> Map.toArray
            let totalActualPayments = scheduleArray |> Array.sumBy (snd >> _.ActualPayments >> Array.sumBy ActualPayment.total)
            scheduleArray
            |> Array.mapFold(fun runningTotal (d, si) ->
                let totalScheduledPayments = ScheduledPayment.total si.ScheduledPayment
                let amountOfScheduledPaymentPaidOff = Cent.min runningTotal totalScheduledPayments
                let newRunningTotal = runningTotal - amountOfScheduledPaymentPaidOff
                (d, { si with EventuallyPaid = amountOfScheduledPaymentPaidOff }), newRunningTotal
            ) totalActualPayments
            |> fst
            |> Map.ofArray

        /// take the total actual payments for a given day, and allocate them to the scheduled payments in turn throughout the entire schedule, 
        /// with the first scheduled payments being paid off first
        let allocateActualPayments (schedule: Map<int<OffsetDay>, ScheduleItem>) =
            ()

        // modifies missed payments or underpayments to reflect whether they are paid later in full or part or not at all within the payment window
        // note: this is useful for credit reporting so as not to penalise those who pay late rather than not at all
        let markMissedPaymentsAsLate (schedule: Map<int<OffsetDay>, ScheduleItem>) =
            schedule
            |> Map.toArray
            |> Array.groupBy (snd >> _.Window)
            |> Array.map snd
            |> Array.filter (Array.isEmpty >> not)
            |> Array.map(fun v ->
                {|
                    OffsetDay = v |> Array.head |> fst
                    PaymentDueTotal = v |> Array.sumBy (snd >> _.PaymentDue)
                    ActualPaymentTotal = v |> Array.sumBy (snd >> _.ActualPayments >> Array.sumBy ActualPayment.total)
                    GeneratedPaymentTotal = v |> Array.sumBy (snd >> _.GeneratedPayment >> GeneratedPayment.Total)
                    PaymentStatus = v |> Array.head |> snd |> _.PaymentStatus
                |}
            )
            |> Array.filter(fun a -> a.PaymentStatus = MissedPayment || a.PaymentStatus = Underpayment)
            |> Array.choose(fun a ->
                match a.ActualPaymentTotal + a.GeneratedPaymentTotal, a.PaymentDueTotal with
                | NotPaidAtAll ->
                    None
                | SomePaid shortfall ->
                    Some (a.OffsetDay, PaidLaterOwing shortfall)
                | FullyPaid ->
                    Some (a.OffsetDay, PaidLaterInFull)
            )
            |> Map.ofArray
            |> fun m ->
                if m |> Map.isEmpty then
                    schedule
                else
                    schedule
                    |> Map.map(fun d si ->
                        match m |> Map.tryFind d with
                        | Some cps -> { si with PaymentStatus = cps }
                        | None -> si
                    )
        // get the interest rounding method from the schedule parameters (usually it is advisable to round interest down to avoid exceeding caps)
        let interestRounding = sp.InterestConfig.InterestRounding
        // get an array of dates on which charges are not incurred
        let chargesHolidays = Charge.holidayDates sp.ChargeConfig sp.StartDate
        // calculates the total fees payable up to a particular day, based on a proportion of days elapsed vs total number of days in the original schedule
        let calculateFees appliedPaymentDay originalFinalPaymentDay =
            if originalFinalPaymentDay <= 0<OffsetDay> then
                0L<Cent>
            elif appliedPaymentDay > originalFinalPaymentDay then
                0L<Cent>
            else
                decimal feesTotal * (decimal originalFinalPaymentDay - decimal appliedPaymentDay) / decimal originalFinalPaymentDay |> Cent.round RoundUp
        // return the amortisation schedule
        appliedPayments
        // convert the map to an array to allow scanning
        |> Map.toArray
        // generate the amortisation schedule
        |> Array.scan(fun ((siOffsetDay, si), a) (appliedPaymentDay, ap) ->
            // determine the window and increment every time a new scheduled payment is due
            let window = if ScheduledPayment.isSome ap.ScheduledPayment then si.Window + 1 else si.Window
            // get an array of advances
            // note: assumes single advance on day 0 (multiple advances are not currently supported), so this is based purely on the principal
            let advances = if appliedPaymentDay = 0<OffsetDay> then [| sp.Principal |] else [||]
            // calculates the simple interest that has accrued since the previous item
            let simpleInterestM =
                // if the principal balance is negative, apply any rate on negative balances and disregard any daily interest caps
                if si.PrincipalBalance <= 0L<Cent> then
                    dailyInterestRates siOffsetDay appliedPaymentDay
                    |> Array.map(fun dr -> { dr with InterestRate = sp.InterestConfig.RateOnNegativeBalance })
                    |> Interest.calculate (si.PrincipalBalance + si.FeesBalance) ValueNone interestRounding
                // otherwise, apply the daily interest rates as normal, applied daily caps as necessary
                else
                    dailyInterestRates siOffsetDay appliedPaymentDay
                    |> Interest.calculate (si.PrincipalBalance + si.FeesBalance) sp.InterestConfig.Cap.DailyAmount interestRounding
            // cap the simple interest against the total interest cap
            let cappedSimpleInterestM = if a.CumulativeSimpleInterestM + simpleInterestM >= totalInterestCapM then totalInterestCapM - a.CumulativeSimpleInterestM else simpleInterestM
            // get any values for original simple interest and contractual interest from any original schedule payment on the day
            let originalSimpleInterestL, contractualInterestM =
                ap.ScheduledPayment.Original
                |> ValueOption.map(fun op -> (op.SimpleInterest, op.ContractualInterest))
                |> ValueOption.defaultValue (0L<Cent>, 0m<Cent>)
            // apply the cumulative simple interest to the accumulator
            let accumulator =
                { a with
                    CumulativeSimpleInterestM = a.CumulativeSimpleInterestM + cappedSimpleInterestM
                }
            // calculate any new interest accrued since the previous item, according to the interest method supplied in the schedule parameters
            let newInterestM =
                match sp.InterestConfig.Method with
                | Interest.Method.AddOn ->
                    if si.BalanceStatus <> ClosedBalance then
                        a.CumulativeSimpleInterestM + cappedSimpleInterestM
                        |> fun i ->
                            if i > initialInterestBalanceM then
                                i - initialInterestBalanceM
                            else
                                0m<Cent>
                        |> min cappedSimpleInterestM
                    else
                        0m<Cent>
                | Interest.Method.Simple -> simpleInterestM
            // cap the new interest against the total interest cap
            let cappedNewInterestM = if a.CumulativeInterest + newInterestM >= totalInterestCapM then totalInterestCapM - a.CumulativeInterest else newInterestM
            // of the actual payments made on the day, sum any that are confirmed or written off
            let confirmedPaymentTotal =
                ap.ActualPayments
                |> Array.sumBy(fun ap -> match ap.ActualPaymentStatus with ActualPaymentStatus.Confirmed ap -> ap | ActualPaymentStatus.WriteOff ap -> ap | _ -> 0L<Cent>)
            // of the actual payments made on the day, sum any that are still pending
            let pendingPaymentTotal =
                ap.ActualPayments
                |> Array.sumBy(fun ap -> match ap.ActualPaymentStatus with ActualPaymentStatus.Pending ap -> ap | _ -> 0L<Cent>)
            // apportion the interest
            let interestPortionM =
                // if a refund is made and the settlement figure is postive, the payment should be apportioned to principal rather than interest (this likely represents a goodwill gesture so should directly benefit the customer)
                if confirmedPaymentTotal < 0L<Cent> && si.SettlementFigure.IsSome && si.SettlementFigure.Value >= 0L<Cent> then
                    0m<Cent>
                // otherwise, add new interest to the interest balance as normal
                else
                    cappedNewInterestM + si.InterestBalance
            // get the rounded interest portion
            let interestPortionL = interestPortionM |> Cent.fromDecimalCent interestRounding
            // update the accumulator
            let accumulator =
                { accumulator with
                    CumulativeScheduledPayments = a.CumulativeScheduledPayments + ScheduledPayment.total ap.ScheduledPayment
                    CumulativeActualPayments = a.CumulativeActualPayments + confirmedPaymentTotal + pendingPaymentTotal
                    CumulativeInterest = a.CumulativeInterest + cappedNewInterestM
                }
            // keep track of any excess payments made to offset against future payments due
            let extraPaymentsBalance = a.CumulativeActualPayments - a.CumulativeScheduledPayments - a.CumulativeGeneratedPayments
            // determine any payment due on the day
            let paymentDue =
                // if the balance is closed or a refund is due, no payment is due
                if si.BalanceStatus = ClosedBalance || si.BalanceStatus = RefundDue then
                    0L<Cent>
                // otherwise, calculate the payment due based on scheduled payments and various balances
                else
                    match ap.ScheduledPayment.Original, ap.ScheduledPayment.Rescheduled with
                    // always make rescheduled payment value due in full
                    | _, ValueSome rp ->
                        rp.Value
                    // if the original payment is cancelled due to rescheduling, there nothing is due
                    | ValueSome op, _ when op.Value = 0L<Cent> ->
                        0L<Cent>
                    // reduce the payment due if early/extra payments have been made
                    | ValueSome op, _ when extraPaymentsBalance > 0L<Cent> ->
                        op.Value - extraPaymentsBalance
                    // non-zero original payments are due in full
                    | ValueSome op, _
                        -> op.Value
                    // if there are no original or rescheduled payments on the day, there is nothing due to pay
                    | ValueNone, ValueNone ->
                        0L<Cent>
                    // payment due should never exceed settlement figure
                    |> Cent.min (si.PrincipalBalance + si.FeesBalance + interestPortionL)
                    // payment due should never be negative
                    |> Cent.max 0L<Cent>
                    // apply minimum payment rules
                    |> fun p ->
                        match sp.PaymentConfig.MinimumPayment with
                        | NoMinimumPayment -> p
                        | DeferOrWriteOff minimumPayment when p < minimumPayment -> 0L<Cent>
                        | ApplyMinimumPayment minimumPayment when p < minimumPayment -> p
                        | _ -> p
            // determine the total of any underpayment
            let underpaymentTotal =
                match ap.PaymentStatus with
                | MissedPayment ->
                    paymentDue
                | Underpayment ->
                    paymentDue - ap.NetEffect
                | _ ->
                    0L<Cent>
            // determine the total and details of any charges incurred
            let newChargesTotal, incurredCharges =
                if paymentDue = 0L<Cent> then
                    0L<Cent>, [||]
                else
                    if chargesHolidays |> Array.exists ((=) (int siOffsetDay)) then
                        0L<Cent>, [||]
                    else
                        Charge.grandTotal sp.ChargeConfig underpaymentTotal (ValueSome ap.ChargeTypes), ap.ChargeTypes
            // apportion the charges
            let chargesPortion = newChargesTotal + si.ChargesBalance |> Cent.max 0L<Cent>
            // for future days, assume that the payment will be made in full and on schedule, yielding a full net effect and allowing meaningful inspection of the future schedule
            // (e.g. seeing if the schedule will be settled as agreed)
            let netEffect = if appliedPaymentDay > asOfDay then Cent.min ap.NetEffect paymentDue else ap.NetEffect
            // simplifies any refund apportionment by modifying the sign of certain values depending on whether the net effect is positive or negative
            let sign: int64<Cent> -> int64<Cent> = if netEffect < 0L<Cent> then (( * ) -1L) else id
            // get the rounded cumulative simple interest
            let cumulativeSimpleInterestL = accumulator.CumulativeSimpleInterestM |> Cent.fromDecimalCent interestRounding
            // 
            let generatedSettlementPayment, interestAdjustmentM =
                match sp.InterestConfig.Method with
                | Interest.Method.AddOn when si.BalanceStatus <> ClosedBalance ->
                    // get a settlement figure for the add-on interest method based on the actual simple interest accrued up to now
                    let settlement = sp.Principal + cumulativeSimpleInterestL - accumulator.CumulativeActualPayments
                    // determine whether an interest adjustment is required based on the difference between cumulative simple interest and the initial interest balance
                    let interestAdjustment =
                        if (ap.GeneratedPayment = ToBeGenerated || settlement <= 0L<Cent>) && si.BalanceStatus <> RefundDue && cappedNewInterestM = 0m<Cent> then // cappedNewInterest check here avoids adding an interest adjustment twice (one for generated payment, one for final payment)
                            accumulator.CumulativeSimpleInterestM - initialInterestBalanceM
                            |> fun i -> if abs i < 1m<Cent> then 0m<Cent> else i
                            |> fun i -> if accumulator.CumulativeSimpleInterestM + i >= totalInterestCapM then totalInterestCapM - accumulator.CumulativeSimpleInterestM else i
                        else
                            0m<Cent>
                    settlement, interestAdjustment
                // otherwise, calculate this later (unless closed balance, as not applicable)
                | _ ->
                    0L<Cent>, 0m<Cent>
            // refine the capped new interest value using any interest adjustment, and ignore any value less than one cent
            let cappedNewInterestM' = cappedNewInterestM + interestAdjustmentM |> Interest.ignoreFractionalCent
            // get the rounded value of the interest adjustment
            let interestAdjustmentL = interestAdjustmentM |> Cent.fromDecimalCent interestRounding
            // refine the interest portion based on any interest adjustment, and again check against the total interest cap
            let interestPortionL' =
                (a.CumulativeInterestPortions, interestPortionL + interestAdjustmentL, Cent.fromDecimalCent interestRounding totalInterestCapM)
                |> fun (cip, i, tic) -> if cip + i >= tic then tic - cip else i
            // determine how much of the net effect can be apportioned and whether any immediate adjustments need to be made to the scheduled payment due to charges and interest, depending on settings
            let assignable, scheduledPaymentAdjustment =
                if netEffect = 0L<Cent> then
                    0L<Cent>, 0L<Cent>
                else
                    match sp.PaymentConfig.ScheduledPaymentOption with
                    | AsScheduled ->
                        sign netEffect - sign chargesPortion - sign interestPortionL', 0L<Cent>
                    | AddChargesAndInterest ->
                        sign netEffect, sign chargesPortion - sign interestPortionL'
            // refine the scheduled payment with any adjustment
            let scheduledPayment = { ap.ScheduledPayment with Adjustment = scheduledPaymentAdjustment }
            // apportion the fees
            let feesPortion =
                match sp.FeeConfig.FeeAmortisation with
                | Fee.FeeAmortisation.AmortiseBeforePrincipal ->
                    Cent.min si.FeesBalance assignable
                | Fee.FeeAmortisation.AmortiseProportionately ->
                    feesPercentage
                    |> Percent.toDecimal
                    |> fun m ->
                        if (1m + m) = 0m then 0L<Cent>
                        else decimal assignable * m / (1m + m) |> Cent.round RoundUp |> Cent.max 0L<Cent> |> Cent.min si.FeesBalance
            // determine the value of any fee refund in the event of settlement, depending on settings
            let feesRefundIfSettled =
                match sp.FeeConfig.SettlementRefund with
                | Fee.SettlementRefund.ProRata ->
                    let originalFinalPaymentDay = sp.ScheduleConfig |> generatePaymentMap sp.StartDate |> Map.keys |> Seq.toArray |> Array.tryLast |> Option.defaultValue 0<OffsetDay>
                    calculateFees appliedPaymentDay originalFinalPaymentDay
                | Fee.SettlementRefund.ProRataRescheduled originalFinalPaymentDay ->
                    calculateFees appliedPaymentDay originalFinalPaymentDay
                | Fee.SettlementRefund.Balance ->
                    a.CumulativeFees
                | Fee.SettlementRefund.Zero ->
                    0L<Cent>
            // ensure any fee refund is positive
            let feesRefund = Cent.max 0L<Cent> feesRefundIfSettled
            // refine the settlement figure depending on the interest method
            let generatedSettlementPayment' =
                match sp.InterestConfig.Method with
                | Interest.Method.AddOn -> generatedSettlementPayment
                | _ -> si.PrincipalBalance + si.FeesBalance - feesRefund + interestPortionL' + chargesPortion
            // refine the fee portion and refund if a refund is actually applied on the day, i.e. if the net effect covers the settlement figure
            let feesPortion', feesRefund' =
                if feesPortion > 0L<Cent> && generatedSettlementPayment' <= netEffect then
                    Cent.max 0L<Cent> (si.FeesBalance - feesRefund), feesRefund
                else
                    sign feesPortion, 0L<Cent>
            // apportion the principal
            let principalPortion = Cent.max 0L<Cent> (assignable - feesPortion')
            // calculate the principal balance
            let principalBalance = si.PrincipalBalance - sign principalPortion
            // if any future payment creates a negative principal balance, adjust these figures accordingly
            let paymentDue', netEffect', principalPortion', principalBalance' =
                if ap.PaymentStatus = NotYetDue && feesRefund' > 0L<Cent> && principalBalance < 0L<Cent> then
                    paymentDue + principalBalance, netEffect + principalBalance, sign principalPortion + principalBalance, 0L<Cent>
                else
                    paymentDue, netEffect, sign principalPortion, principalBalance
            // if any charges or interest are not fully covered by the actual payment total, determine the values to carry over to the next item
            let carriedCharges, carriedInterestL =
                if sign chargesPortion > sign netEffect then
                    chargesPortion - netEffect, interestPortionL
                elif netEffect = 0L<Cent> && interestPortionM < 0m<Cent> then
                    0L<Cent>, interestPortionL
                elif sign chargesPortion + sign interestPortionL' > sign netEffect then
                    0L<Cent>, interestPortionL - (netEffect - chargesPortion)
                else
                    0L<Cent>, 0L<Cent>
            // get the date equivalent of the offset day for further calculation
            let offsetDate = sp.StartDate.AddDays(int appliedPaymentDay)
            // determine the principal balance
            let balanceStatus = getBalanceStatus principalBalance'
            // calculate the interest balance as a decimal
            let interestBalanceM = si.InterestBalance + cappedNewInterestM' - Cent.toDecimalCent (interestPortionL' - carriedInterestL)
            // get the rounded interest balance
            let interestBalanceL = interestBalanceM |> decimal |> Cent.round interestRounding
            // creates an item that will create a settlement
            let settlementItem () =
                // if the balance is already closed, settlement is no longer required
                let paymentStatus =
                    match si.BalanceStatus with
                    | ClosedBalance ->
                        NoLongerRequired
                    | _ ->
                        Generated
                // refine the settlement figure if necessary by subtracting any payment made on the same day
                let settlementFigure =
                    match sp.InterestConfig.Method with
                    | Interest.Method.AddOn ->
                        generatedSettlementPayment'
                    | _ ->
                        generatedSettlementPayment' - netEffect'
                // convert the generated payment placeholder with an actual settlement figure 
                let generatedPayment =
                    match ap.GeneratedPayment with
                    | ToBeGenerated ->
                        GeneratedValue settlementFigure
                    | gp ->
                        gp
                // create the schedule item
                let scheduleItem = {
                    Window = window
                    OffsetDate = offsetDate
                    Advances = advances
                    ScheduledPayment = scheduledPayment
                    PaymentDue = paymentDue'
                    EventuallyPaid = 0L<Cent>
                    ActualPayments = ap.ActualPayments
                    Allocations = [||]
                    GeneratedPayment = generatedPayment
                    NetEffect = netEffect + GeneratedPayment.Total generatedPayment
                    PaymentStatus = paymentStatus
                    BalanceStatus = ClosedBalance
                    OriginalSimpleInterest = originalSimpleInterestL
                    ContractualInterest = contractualInterestM
                    SimpleInterest = cappedSimpleInterestM
                    NewInterest = cappedNewInterestM'
                    NewCharges = incurredCharges
                    PrincipalPortion = si.PrincipalBalance
                    FeesPortion = si.FeesBalance - feesRefund
                    InterestPortion = interestPortionL'
                    ChargesPortion = chargesPortion
                    FeesRefund = feesRefund
                    PrincipalBalance = 0L<Cent>
                    FeesBalance = 0L<Cent>
                    InterestBalance = 0m<Cent>
                    ChargesBalance = 0L<Cent>
                    SettlementFigure = ValueSome settlementFigure
                    FeesRefundIfSettled = feesRefundIfSettled
                }
                // returns the offset day, schedule item, generated payment, and interest rounding difference (zero in this case as it is already factored into the settlement figure)
                appliedPaymentDay, scheduleItem, settlementFigure, 0m<Cent>
            // creates a normal item, i.e. one that will not create a settlement
            let nonSettlementItem () =
                // refine the payment status based on the balance status
                let paymentStatus =
                    match si.BalanceStatus with
                    | ClosedBalance ->
                        NoLongerRequired
                    | RefundDue when netEffect' < 0L<Cent> ->
                        Refunded
                    | RefundDue when netEffect' > 0L<Cent> ->
                        Overpayment
                    | RefundDue ->
                        NoLongerRequired
                    | _ ->
                        if ap.PaymentStatus <> InformationOnly && paymentDue' = 0L<Cent> && confirmedPaymentTotal = 0L<Cent> && pendingPaymentTotal = 0L<Cent> && GeneratedPayment.Total ap.GeneratedPayment = 0L<Cent> then
                            NothingDue
                        else
                            ap.PaymentStatus
                // refine the settlement figure if necessary by subtracting any payment made on the same day, or nullifying it if there are payments pending (settlement cannot be made in this case)
                let settlementFigure =
                    match pendingPaymentTotal, ap.PaymentStatus, sp.InterestConfig.Method with
                    | pp, _, _ when pp > 0L<Cent> ->
                        ValueNone
                    | _, NotYetDue, _
                    | _, _, Interest.Method.AddOn ->
                        ValueSome generatedSettlementPayment'
                    | _, _, _ ->
                        ValueSome <| generatedSettlementPayment' - netEffect'
                // refine the interest portion by adding carried interest
                let interestPortionL' = interestPortionL' - carriedInterestL
                // create the schedule item
                let scheduleItem = {
                    Window = window
                    OffsetDate = offsetDate
                    Advances = advances
                    ScheduledPayment = scheduledPayment
                    PaymentDue = paymentDue'
                    EventuallyPaid = 0L<Cent>
                    ActualPayments = ap.ActualPayments
                    Allocations = [||]
                    GeneratedPayment = ap.GeneratedPayment
                    NetEffect = netEffect'
                    PaymentStatus = paymentStatus
                    BalanceStatus = balanceStatus
                    OriginalSimpleInterest = originalSimpleInterestL
                    ContractualInterest = contractualInterestM
                    SimpleInterest = cappedSimpleInterestM
                    NewInterest = cappedNewInterestM'
                    NewCharges = incurredCharges
                    PrincipalPortion = principalPortion'
                    FeesPortion = feesPortion'
                    InterestPortion = interestPortionL'
                    ChargesPortion = chargesPortion - carriedCharges
                    FeesRefund = feesRefund'
                    PrincipalBalance = principalBalance'
                    FeesBalance = si.FeesBalance - feesPortion' - feesRefund'
                    InterestBalance = interestBalanceM |> Interest.ignoreFractionalCent
                    ChargesBalance = si.ChargesBalance + newChargesTotal - chargesPortion + carriedCharges
                    SettlementFigure = settlementFigure
                    FeesRefundIfSettled = if paymentStatus = NoLongerRequired then 0L<Cent> else feesRefundIfSettled
                }
                // calculate the rounding difference between the decimal and integer interest balances
                let interestRoundingDifferenceM = if interestPortionL' = 0L<Cent> then 0m<Cent> else interestBalanceM - Cent.toDecimalCent interestBalanceL
                // returns the offset day, schedule item, generated payment, and interest rounding difference (zero in this case as it is already factored into the settlement figure)
                appliedPaymentDay, scheduleItem, 0L<Cent>, interestRoundingDifferenceM
            // get the relevant type of item based on the intended purpose
            let offsetDay, scheduleItem, generatedPayment, interestRoundingDifferenceM =
                match ap.GeneratedPayment, settlementDay with
                | ToBeGenerated, ValueSome SettlementDay.SettlementOnAsOfDay when asOfDay = appliedPaymentDay ->
                    settlementItem ()
                | ToBeGenerated, ValueSome (SettlementDay.SettlementOn day) when day = appliedPaymentDay ->
                    settlementItem ()
                | GeneratedValue gv, _ ->
                    failwith $"Unexpected value: {gv}"
                | NoGeneratedPayment, _
                | ToBeGenerated, ValueNone
                | ToBeGenerated, ValueSome (SettlementDay.SettlementOn _)
                | ToBeGenerated, ValueSome SettlementDay.SettlementOnAsOfDay ->
                    nonSettlementItem ()
            // refine the accumulator values
            let accumulator' =
                { accumulator with
                    CumulativeScheduledPayments = accumulator.CumulativeScheduledPayments + scheduledPaymentAdjustment
                    CumulativeGeneratedPayments = a.CumulativeGeneratedPayments + generatedPayment
                    CumulativeFees = a.CumulativeFees + feesPortion'
                    CumulativeInterest = accumulator.CumulativeInterest - interestRoundingDifferenceM
                    CumulativeInterestPortions = a.CumulativeInterestPortions + scheduleItem.InterestPortion
                }
            // return the values for the next scan iteration
            (offsetDay, scheduleItem), accumulator'
        ) (
            // initialise the values for the scan
            (0<OffsetDay>,
            { ScheduleItem.initial with
                OffsetDate = sp.StartDate
                Advances = [| sp.Principal |]
                PrincipalBalance = sp.Principal
                FeesBalance = feesTotal
                InterestBalance = initialInterestBalanceM
                SettlementFigure = ValueSome <| sp.Principal + feesTotal
                FeesRefundIfSettled = match sp.FeeConfig.SettlementRefund with Fee.SettlementRefund.Zero -> 0L<Cent> | _ -> feesTotal
            }), {
                CumulativeScheduledPayments = 0L<Cent>
                CumulativeActualPayments = 0L<Cent>
                CumulativeGeneratedPayments = 0L<Cent>
                CumulativeFees = 0L<Cent>
                CumulativeInterest = initialInterestBalanceM
                CumulativeInterestPortions = 0L<Cent>
                CumulativeSimpleInterestM = 0m<Cent>
            }
        )
        // separate and discard the accumulator
        |> Array.unzip
        |> fst
        // handle duplicated initial offset day
        |> fun a -> if (a |> Array.filter(fun (siOffsetDay, _) -> siOffsetDay = 0<OffsetDay>) |> Array.length = 2) then a |> Array.tail else a
        // convert back to a map
        |> Map.ofArray
        // post-process missed payments or underpayments
        |> markMissedPaymentsAsLate
        // populate the EventuallyPaid field so that even payments that are techically missed can have a payment assigned to them if later payments are sufficient to cover them
        |> trackEventuallyPaid

    /// wraps the amortisation schedule in some statistics, and optionally calculates the final APR (optional because it can be processor-intensive)
    let calculateStats sp settlementDay (items: Map<int<OffsetDay>, ScheduleItem>) =
        let finalItemDay, finalItem = items |> Map.maxKeyValue
        let items' = items |> Map.toArray |> Array.map snd
        let principalTotal = items' |> Array.sumBy _.PrincipalPortion
        let feesTotal = items' |> Array.sumBy _.FeesPortion
        let interestTotal = items' |> Array.sumBy _.InterestPortion
        let chargesTotal = items' |> Array.sumBy _.ChargesPortion
        let feesRefund = finalItem.FeesRefund
        let finalPaymentDay = finalItemDay
        let finalBalanceStatus = finalItem.BalanceStatus
        let finalAprSolution =
            match settlementDay with
            | ValueSome _ when finalBalanceStatus = ClosedBalance ->
                items'
                |> Array.filter(fun asi -> asi.NetEffect > 0L<Cent>)
                |> Array.map(fun asi -> { TransferType = Apr.TransferType.Payment; TransferDate = asi.OffsetDate; Value = asi.NetEffect } : Apr.Transfer)
                |> Apr.calculate sp.InterestConfig.AprMethod sp.Principal sp.StartDate
                |> ValueSome
            | _ ->
                 ValueNone
        let scheduledPaymentItems = items |> Map.filter(fun _ si -> ScheduledPayment.isSome si.ScheduledPayment)
        {
            ScheduleItems = items
            FinalScheduledPaymentDay = scheduledPaymentItems |> Map.maxKeyValue |> fst
            FinalScheduledPaymentCount = scheduledPaymentItems |> Map.count
            FinalActualPaymentCount = items' |> Array.sumBy(fun asi -> Array.length asi.ActualPayments)
            FinalApr = finalAprSolution |> ValueOption.map(fun s -> s, Apr.toPercent sp.InterestConfig.AprMethod s)
            FinalCostToBorrowingRatio =
                if principalTotal = 0L<Cent> then Percent 0m
                else decimal (feesTotal + interestTotal + chargesTotal) / decimal principalTotal |> Percent.fromDecimal |> Percent.round 2
            EffectiveInterestRate =
                if finalPaymentDay = 0<OffsetDay> || principalTotal + feesTotal - feesRefund = 0L<Cent> then 0m
                else (decimal interestTotal / decimal (principalTotal + feesTotal - feesRefund)) / decimal finalPaymentDay
                |> Percent |> Interest.Rate.Daily
        }

    /// generates an amortisation schedule and final statistics
    let generate sp settlementDay trimEnd actualPayments =
        let schedule = Scheduling.calculate BelowZero sp
        let scheduledPayments =
            schedule.Items
            |> Array.filter (_.ScheduledPayment >> ScheduledPayment.isSome)
            |> Array.map(fun si ->
                let originalSimpleInterest, contractualInterest =
                    match sp.InterestConfig.Method with
                    | Interest.Method.AddOn ->
                        si.SimpleInterest, Cent.toDecimalCent si.InterestPortion
                    | _ ->
                        0L<Cent>, 0m<Cent>
                si.Day,
                { si.ScheduledPayment with
                    Original = si.ScheduledPayment.Original |> ValueOption.map(fun op -> { op with SimpleInterest = originalSimpleInterest; ContractualInterest = contractualInterest })
                }
            )
            |> Map.ofArray

        let asOfDay = sp.AsOfDate |> OffsetDay.fromDate sp.StartDate

        scheduledPayments
        |> applyPayments asOfDay settlementDay sp.ChargeConfig sp.PaymentConfig.PaymentTimeout actualPayments
        |> calculate sp settlementDay schedule.InitialInterestBalance
        |> if trimEnd then Map.filter(fun _ si -> si.PaymentStatus <> NoLongerRequired) else id
        |> calculateStats sp settlementDay
