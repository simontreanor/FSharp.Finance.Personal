namespace FSharp.Finance.Personal

/// calculating the principal balance over time, taking into account the effects of charges, interest and fee
module Amortisation =

    open AppliedPayment
    open Calculation
    open DateDay
    open Formatting
    open Scheduling

    /// the day of the amortisation schedule, which can be a normal day, evaluation day or settlement day
    [<Struct>]
    type OffsetDayType =
        | OffsetDay
        | EvaluationDay
        | SettlementDay

    /// the day of the amortisation schedule, which can be a normal day, evaluation day or settlement day
    [<Struct>]
    module OffsetDayType =
        /// HTML formatting to display the amortisation day in a readable format
        let toHtml (offsetDay: int<OffsetDay>) offsetDayType =
            match offsetDayType with
            | OffsetDay -> $"{offsetDay}"
            | EvaluationDay -> $"&#x2605;&nbsp;<b>{offsetDay}</b>"
            | SettlementDay -> $"&#x2713;&nbsp;<b>{offsetDay}</b>"

    /// the status of the balance on a given offset day
    [<Struct; StructuredFormatDisplay("{Html}")>]
    type BalanceStatus =
        /// the balance has been settled in full
        | ClosedBalance
        /// the balance is open, meaning further payments will be required to settle it
        | OpenBalance
        /// due to an overpayment or a refund of charges, a refund is due
        | RefundDue

        /// HTML formatting to display the balance status in a readable format
        member bs.Html =
            match bs with
            | ClosedBalance -> "closed"
            | OpenBalance -> "open"
            | RefundDue -> "refund due"

    /// a breakdown of how an actual payment is apportioned to principal, fee, interest and charges
    type Apportionment = {
        PrincipalPortion: int64<Cent>
        FeePortion: int64<Cent>
        InterestPortion: int64<Cent>
        ChargesPortion: int64<Cent>
    }

    /// a breakdown of how an actual payment is apportioned to principal, fee, interest and charges
    module Apportionment =
        /// add principal, fee, interest and charges to an existing apportionment
        let add principal fee interest charges apportionment = {
            apportionment with
                PrincipalPortion = apportionment.PrincipalPortion + principal
                FeePortion = apportionment.FeePortion + fee
                InterestPortion = apportionment.InterestPortion + interest
                ChargesPortion = apportionment.ChargesPortion + charges
        }

        /// a default value for an apportionment, with all portions set to zero
        let zero = {
            PrincipalPortion = 0L<Cent>
            FeePortion = 0L<Cent>
            InterestPortion = 0L<Cent>
            ChargesPortion = 0L<Cent>
        }

        /// the total value of all the portions of an apportionment
        let total apportionment =
            apportionment.PrincipalPortion
            + apportionment.FeePortion
            + apportionment.InterestPortion
            + apportionment.ChargesPortion

    /// amortisation schedule item showing apportionment of payments to principal, fee, interest and charges
    type ScheduleItem = {
        /// the offset day type
        OffsetDayType: OffsetDayType
        /// the date of amortisation
        OffsetDate: Date
        /// any advance made on the current day, typically the principal on day 0 for a single-advance transaction
        Advances: int64<Cent> array
        /// any payment scheduled on the current day
        ScheduledPayment: ScheduledPayment
        /// the window during which a scheduled payment can be made; if the date is missed, the payment is late, but if the window is missed, the payment is missed
        Window: int
        /// any payment scheduled on the current day
        PaymentDue: int64<Cent>
        /// any payments actually made on the current day
        ActualPayments: ActualPayment array
        /// a payment generated by the system e.g. to calculate a settlement figure
        GeneratedPayment: GeneratedPayment
        /// the net effect of the scheduled and actual payments, or, for future days, what the net effect would be if the scheduled payment was actually made
        NetEffect: int64<Cent>
        /// the status based on the payments and net effect
        PaymentStatus: PaymentStatus
        /// the overall balance status
        BalanceStatus: BalanceStatus
        /// any new charges incurred between the previous amortisation day and the current day
        NewCharges: AppliedCharge array
        /// the portion of the net effect assigned to the charges
        ChargesPortion: int64<Cent>
        /// the actuarial interest accruable between the previous amortisation day and the current day
        ActuarialInterest: decimal<Cent>
        /// the new interest charged between the previous amortisation day and the current day, less any initial interest
        NewInterest: decimal<Cent>
        /// the portion of the net effect assigned to the interest
        InterestPortion: int64<Cent>
        /// any fee rebate, on the final amortisation day, if the fee is pro-rated in the event of early settlement
        FeeRebate: int64<Cent>
        /// the portion of the net effect assigned to the fee
        FeePortion: int64<Cent>
        /// the portion of the net effect assigned to the principal
        PrincipalPortion: int64<Cent>
        /// the charges balance to be carried forward
        ChargesBalance: int64<Cent>
        /// the interest balance to be carried forward
        InterestBalance: decimal<Cent>
        /// the fee balance to be carried forward
        FeeBalance: int64<Cent>
        /// the principal balance to be carried forward
        PrincipalBalance: int64<Cent>
        /// the settlement figure as of the current day
        SettlementFigure: int64<Cent>
        /// the pro-rated fee as of the current day
        FeeRebateIfSettled: int64<Cent>
    }

    /// amortisation schedule item showing apportionment of payments to principal, fee, interest and charges
    module ScheduleItem =
        /// a default value with no data
        let zero = {
            OffsetDayType = OffsetDay
            OffsetDate = Unchecked.defaultof<Date>
            Advances = [||]
            ScheduledPayment = ScheduledPayment.zero
            Window = 0
            PaymentDue = 0L<Cent>
            ActualPayments = [||]
            GeneratedPayment = NoGeneratedPayment
            NetEffect = 0L<Cent>
            PaymentStatus = NoneScheduled
            BalanceStatus = OpenBalance
            ActuarialInterest = 0m<Cent>
            NewInterest = 0m<Cent>
            NewCharges = [||]
            PrincipalPortion = 0L<Cent>
            FeePortion = 0L<Cent>
            InterestPortion = 0L<Cent>
            ChargesPortion = 0L<Cent>
            FeeRebate = 0L<Cent>
            PrincipalBalance = 0L<Cent>
            FeeBalance = 0L<Cent>
            InterestBalance = 0m<Cent>
            ChargesBalance = 0L<Cent>
            SettlementFigure = 0L<Cent>
            FeeRebateIfSettled = 0L<Cent>
        }

        /// formats the schedule item as an HTML row
        let toHtmlRow (p: Parameters) settlementDay offsetDay scheduleItem =
            let fields =
                [|
                    yield "", $"{OffsetDayType.toHtml offsetDay scheduleItem.OffsetDayType}"
                    yield " style=\"white-space: nowrap;\"", $"%A{scheduleItem.OffsetDate}"
                    yield "", $"{scheduleItem.Advances |> Array.map formatCent |> Array.toStringOrNa}"
                    yield " style=\"white-space: nowrap;\"", $"{scheduleItem.ScheduledPayment}"
                    yield "", $"{scheduleItem.Window}"
                    yield "", $"{formatCent scheduleItem.PaymentDue}"
                    yield "", $"""{scheduleItem.ActualPayments |> Array.toStringOrNa |> _.Replace(" ", "&nbsp;")}"""
                    if settlementDay <> SettlementDay.NoSettlement then
                        yield "", $"{scheduleItem.GeneratedPayment}"
                    yield "", $"{formatCent scheduleItem.NetEffect}"
                    yield "", $"""{scheduleItem.PaymentStatus.Html.Replace(" ", "&nbsp;")}"""
                    yield "", $"""{scheduleItem.BalanceStatus.Html.Replace(" ", "&nbsp;")}"""
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "", $"""{Array.toStringOrNa scheduleItem.NewCharges |> _.Replace(" ", "&nbsp;")}"""
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.ChargesPortion}"
                    yield "", $"{formatDecimalCent scheduleItem.ActuarialInterest}"
                    yield "", $"{formatDecimalCent scheduleItem.NewInterest}"
                    yield "", $"{formatCent scheduleItem.InterestPortion}"
                    if p.Basic.FeeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.FeeRebateIfSettled}"
                    if p.Basic.FeeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.FeeRebate}"
                    if p.Basic.FeeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.FeePortion}"
                    yield "", $"{formatCent scheduleItem.PrincipalPortion}"
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.ChargesBalance}"
                    yield "", $"{formatDecimalCent scheduleItem.InterestBalance}"
                    if p.Basic.FeeConfig.IsSome then
                        yield "", $"{formatCent scheduleItem.FeeBalance}"
                    yield "", $"{formatCent scheduleItem.PrincipalBalance}"
                    yield "", $"{formatCent scheduleItem.SettlementFigure}"
                |]
                |> Array.mapi (fun i (style, content) ->
                    $"""
        <td class="ci{i:``00``}"{style}>{content}</td>"""
                )
                |> String.concat ""

            $"""
    <tr style="text-align: right;">{fields}
    </tr>"""


    /// a container for aggregating figures separately from the main schedule
    [<Struct>]
    type Accumulator = {
        /// the total of scheduled payments up to the current day
        CumulativeScheduledPayments: int64<Cent>
        /// the total of actual payments made up to the current day
        CumulativeActualPayments: int64<Cent>
        /// the total of generated payments made up to the current day
        CumulativeGeneratedPayments: int64<Cent>
        /// the total fee paid up to the current day
        CumulativeFee: int64<Cent>
        /// the total of interest accrued up to the current day
        CumulativeInterest: decimal<Cent>
        /// the total of interest portions up to the current day
        CumulativeInterestPortions: int64<Cent>
        /// the total of actuarial interest accrued up to the current day
        CumulativeActuarialInterestM: decimal<Cent>
    }

    /// final statistics resulting from the calculations
    [<Struct>]
    type FinalStats = {
        /// the final number of scheduled payments in the schedule
        RequiredScheduledPaymentCount: int
        /// the offset day of the final required scheduled payment
        LastRequiredScheduledPaymentDay: int<OffsetDay> voption
        /// the final number of actual payments in the schedule (multiple payments made on the same day are counted separately)
        FinalActualPaymentCount: int
        /// the offset day of the final actual payment
        LastActualPaymentDay: int<OffsetDay> voption
        /// the final ratio of (fee + interest + charges) to principal
        FinalCostToBorrowingRatio: Percent
        /// the daily interest rate derived from interest over (principal + fee), ignoring charges
        EffectiveInterestRate: Interest.Rate
        /// the generated settlement figure from the schedule
        SettlementFigure: (int<OffsetDay> * int64<Cent>) voption
        /// the final balance status of the schedule
        FinalBalanceStatus: BalanceStatus
    }

    /// final statistics resulting from the calculations
    module FinalStats =
        /// formats the schedule stats as an HTML table (excluding the items, which are rendered separately)
        let toHtmlTable finalStats =
            $"""
<table>
    <tr>
        <td>Generated settlement: <i>{finalStats.SettlementFigure
                                      |> function
                                          | ValueSome(d, gv) -> $"{formatCent gv} on day {d}"
                                          | ValueNone -> "<i>n/a</i>"}</i></td>
        <td>Final balance status: <i>{finalStats.FinalBalanceStatus}</i></td>
    </tr>
    <tr>
        <td>Effective interest rate: <i>{finalStats.EffectiveInterestRate}</i></td>
        <td>Final cost-to-borrowing ratio: <i>{finalStats.FinalCostToBorrowingRatio}</i></td>
    </tr>
    <tr>
        <td>Required scheduled payment count: <i>{finalStats.RequiredScheduledPaymentCount}</i></td>
        <td>Last required scheduled payment day: <i>{finalStats.LastRequiredScheduledPaymentDay
                                                     |> ValueOption.map string
                                                     |> ValueOption.defaultValue "n/a"}</i></td>
    </tr>
    <tr>
        <td>Final actual payment count: <i>{finalStats.FinalActualPaymentCount}</i></td>
        <td>Last actual payment day: <i>{finalStats.LastActualPaymentDay
                                         |> ValueOption.map string
                                         |> ValueOption.defaultValue "n/a"}</i></td>
    </tr>
</table>
"""

    /// a schedule showing the amortisation, itemising the effects of payments and calculating balances for each item, and producing some final statistics resulting from the calculations
    [<Struct>]
    type Schedule = {
        /// a list of amortisation items, showing the events and calculations for a particular offset day
        ScheduleItems: Map<int<OffsetDay>, ScheduleItem>
        /// final stats resulting from the calculations
        FinalStats: FinalStats
    }

    /// results of the amortisation schedule generation
    type GenerationResult = {
        AmortisationSchedule: Schedule
        BasicSchedule: BasicSchedule
    }

    /// a schedule showing the amortisation, itemising the effects of payments and calculating balances for each item, and producing some final statistics resulting from the calculations
    module Schedule =
        /// formats the schedule items as an HTML table (stats can be rendered separately)
        let toHtmlTable (p: Parameters) schedule =
            let fieldHeaders =
                [|
                    yield "Day"
                    yield "Datestamp"
                    yield "Advances"
                    yield "Scheduled payment"
                    yield "Window"
                    yield "Payment due"
                    yield "Actual payments"
                    if not p.Advanced.SettlementDay.IsNoSettlement then
                        yield "Generated payment"
                    yield "Net effect"
                    yield "Payment status"
                    yield "Balance status"
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "New charges"
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "Charges portion"
                    yield "Actuarial interest"
                    yield "New interest"
                    yield "Interest portion"
                    if p.Basic.FeeConfig.IsSome then
                        yield "Fee rebate if&nbsp;settled"
                    if p.Basic.FeeConfig.IsSome then
                        yield "Fee rebate"
                    if p.Basic.FeeConfig.IsSome then
                        yield "Fee portion"
                    yield "Principal portion"
                    if p.Advanced.ChargeConfig.IsSome then
                        yield "Charges balance"
                    yield "Interest balance"
                    if p.Basic.FeeConfig.IsSome then
                        yield "Fee balance"
                    yield "Principal balance"
                    yield "Settlement figure"
                |]
                |> Array.mapi (fun i fh ->
                    $"""
        <th class="ci{i:``00``}" style="text-align: right;">{fh}</th>"""
                )
                |> String.concat ""

            $"""
<table>
    <thead style="vertical-align: bottom;">{fieldHeaders}
    </thead>{schedule.ScheduleItems
             |> Map.map (ScheduleItem.toHtmlRow p p.Advanced.SettlementDay)
             |> Map.values
             |> String.concat ""}
</table>"""

        /// renders the schedule as an HTML table within a markup file, which can both be previewed in VS Code and imported as XML into Excel
        let outputHtmlToFile folder title description (p: Parameters) (extraInfo: string) generationResult =
            let htmlTitle = $"<h2>{title}</h2>"

            let htmlSchedule = toHtmlTable p generationResult.AmortisationSchedule

            let htmlKey = "<p>Key: &#x2605; = evaluation day; &#x2713; = settlement day</p>"

            let htmlDescription =
                $"""
<h4>Description</h4>
<p><i>{description}</i></p>"""

            let htmlDatestamp =
                $"""
<p>Generated: <i><a href="../GeneratedDate.html">see details</a></i></p>"""

            let htmlBasicParams =
                $"""
<h4>Basic Parameters</h4>{BasicParameters.toHtmlTable p.Basic}"""

            let htmlAdvancedParams =
                $"""
<h4>Advanced Parameters</h4>{AdvancedParameters.toHtmlTable p.Advanced}"""

            let htmlExtraInfo =
                match extraInfo with
                | "" -> ""
                | ei ->
                    $"""
<h4>Extra Info</h4>{ei}"""

            let originalBasicSchedule = calculateBasicSchedule p.Basic

            let htmlInitialSchedule =
                $"""<h4>Initial Schedule</h4>{BasicSchedule.toHtmlTable originalBasicSchedule}"""

            let htmlInitialStats =
                $"""
<h4>Initial Stats</h4>{InitialStats.toHtmlTable originalBasicSchedule.Stats}"""

            let htmlFinalStats =
                $"""
<h4>Final Stats</h4>{FinalStats.toHtmlTable generationResult.AmortisationSchedule.FinalStats}"""

            let filename = $"out/{folder}/{title}.md"

            $"{htmlTitle}{htmlSchedule}{htmlKey}{htmlFinalStats}{htmlDescription}{htmlDatestamp}{htmlBasicParams}{htmlAdvancedParams}{htmlExtraInfo}{htmlInitialSchedule}{htmlInitialStats}"
            |> outputToFile' filename false

    /// calculates the fee total as a percentage of the principal, for further calculation (weighting payments made when apportioning to fee and principal)
    let feePercentage principal feeTotal =
        if principal = 0L<Cent> then
            Percent 0m
        else
            decimal feeTotal / decimal principal |> Percent.fromDecimal

    /// gets the balance status based on the principal balance
    let getBalanceStatus principalBalance =
        if principalBalance = 0L<Cent> then ClosedBalance
        elif principalBalance < 0L<Cent> then RefundDue
        else OpenBalance

    /// determines whether a schedule is settled within any grace period (e.g. no interest may be due if settlement is made within three days of the advance)
    let isSettledWithinGracePeriod (p: Parameters) =
        match p.Advanced.SettlementDay with
        | SettlementDay.SettlementOnEvaluationDay ->
            int <| OffsetDay.fromDate p.Basic.StartDate p.Basic.EvaluationDate
            <= int p.Advanced.InterestConfig.InitialGracePeriod
        | SettlementDay.NoSettlement -> false

    /// pattern matching for payments due vs payments made
    let (|NotPaidAtAll|SomePaid|FullyPaid|) (actualPaymentTotal, paymentDueTotal) =
        if actualPaymentTotal = 0L<Cent> then
            NotPaidAtAll
        elif actualPaymentTotal < paymentDueTotal then
            SomePaid(paymentDueTotal - actualPaymentTotal)
        else
            FullyPaid

    /// modifies missed payments or underpayments to reflect whether they are paid later in full or part or not at all within the payment window
    /// note: this is useful for credit reporting so as not to penalise those who pay late rather than not at all
    let markMissedPaymentsAsLate (schedule: (int<OffsetDay> * ScheduleItem) array) =
        schedule
        |> Array.groupBy (snd >> _.Window)
        |> Array.map snd
        |> Array.filter (Array.isEmpty >> not)
        |> Array.map (fun v -> {|
            OffsetDay = v |> Array.head |> fst
            PaymentDueTotal = v |> Array.sumBy (snd >> _.PaymentDue)
            ActualPaymentTotal = v |> Array.sumBy (snd >> _.ActualPayments >> Array.sumBy ActualPayment.total)
            GeneratedPaymentTotal = v |> Array.sumBy (snd >> _.GeneratedPayment >> GeneratedPayment.total)
            PaymentStatus = v |> Array.head |> snd |> _.PaymentStatus
        |})
        |> Array.filter (fun a -> a.PaymentStatus = MissedPayment || a.PaymentStatus = Underpayment)
        |> Array.choose (fun a ->
            match a.ActualPaymentTotal + a.GeneratedPaymentTotal, a.PaymentDueTotal with
            | NotPaidAtAll -> None
            | SomePaid shortfall -> Some(a.OffsetDay, PaidLaterOwing shortfall)
            | FullyPaid -> Some(a.OffsetDay, PaidLaterInFull)
        )
        |> Map.ofArray
        |> fun m ->
            if m |> Map.isEmpty then
                Map.ofArray schedule
            else
                schedule
                |> Map.ofArray
                |> Map.map (fun d si ->
                    match m |> Map.tryFind d with
                    | Some cps -> { si with PaymentStatus = cps }
                    | None -> si
                )

    /// calculates the total fee payable up to a particular day, based on a proportion of days elapsed vs total number of days in the original schedule
    let calculateFee feeTotal appliedPaymentDay originalFinalPaymentDay =
        if originalFinalPaymentDay <= 0<OffsetDay> then
            0L<Cent>
        elif appliedPaymentDay > originalFinalPaymentDay then
            0L<Cent>
        else
            decimal feeTotal * (decimal originalFinalPaymentDay - decimal appliedPaymentDay)
            / decimal originalFinalPaymentDay
            |> Cent.round RoundUp
            |> max 0L<Cent>

    /// determines any payment due on the day
    let calculatePaymentDue si originalPayment rescheduledPayment extraPaymentsBalance interestPortionL minimumPayment =
        // if the balance is closed or a refund is due, no payment is due
        if si.BalanceStatus = ClosedBalance || si.BalanceStatus = RefundDue then
            0L<Cent>
        // otherwise, calculate the payment due based on scheduled payments and various balances
        else
            match originalPayment, rescheduledPayment with
            // always make rescheduled payment value due in full
            | _, ValueSome rp -> rp.Value
            // if the original payment is cancelled due to rescheduling, there nothing is due
            | ValueSome op, _ when op = 0L<Cent> -> 0L<Cent>
            // reduce the payment due if early/extra payments have been made
            | ValueSome op, _ when extraPaymentsBalance > 0L<Cent> -> op - extraPaymentsBalance
            // non-zero original payments are due in full
            | ValueSome op, _ -> op
            // if there are no original or rescheduled payments on the day, there is nothing due to pay
            | ValueNone, ValueNone -> 0L<Cent>
            // payment due should never exceed settlement figure
            |> min (si.PrincipalBalance + si.FeeBalance + interestPortionL)
            // payment due should never be negative
            |> max 0L<Cent>
            // apply minimum payment rules
            |> fun payment ->
                match minimumPayment with
                | NoMinimumPayment -> payment
                | DeferOrWriteOff minimumPayment when payment < minimumPayment -> 0L<Cent>
                | ApplyMinimumPayment minimumPayment when payment < minimumPayment -> payment
                | _ -> payment

    /// for UK FCA-regulated agreements, calculates the fee rebate due
    let calculateStatutoryFeeRebate
        bp
        (appliedPayments: Map<int<OffsetDay>, AppliedPayment>)
        initialStats
        appliedPaymentDay
        window
        =
        let originalScheduledPayments =
            appliedPayments
            |> Map.filter (fun _ ap -> ap.ScheduledPayment.Original.IsSome)
            |> Map.toArray
            |> Array.mapi (fun i (d, ap) -> {|
                Window = i
                OffsetDay = d
                OriginalScheduledPaymentValue = ap.ScheduledPayment.Original.Value
            |})

        let unitPeriod =
            match bp.ScheduleConfig with
            | AutoGenerateSchedule ags -> UnitPeriod.Config.unitPeriod ags.UnitPeriodConfig
            | FixedSchedules _
            | CustomSchedule _ ->
                let finalScheduledPaymentDate =
                    initialStats.LastScheduledPaymentDay |> OffsetDay.toDate bp.StartDate

                let transactionTerm =
                    UnitPeriod.transactionTerm bp.StartDate bp.StartDate finalScheduledPaymentDate bp.StartDate

                let paymentDates =
                    originalScheduledPayments
                    |> Array.map (_.OffsetDay >> OffsetDay.toDate bp.StartDate)

                UnitPeriod.nearest transactionTerm [| bp.StartDate |] paymentDates

        let previousScheduledPaymentDate =
            originalScheduledPayments
            |> Array.filter (fun osp -> osp.OffsetDay <= appliedPaymentDay)
            |> Array.last
            |> _.OffsetDay

        let numerator = appliedPaymentDay - previousScheduledPaymentDate |> int
        let denominator = UnitPeriod.roughLength unitPeriod
        let settlementPartPeriod = Fraction.Simple(numerator, denominator)

        let payments =
            originalScheduledPayments
            |> Array.map (fun osp -> osp.Window, osp.OriginalScheduledPaymentValue)

        Interest.calculateRebate
            bp.Principal
            payments
            initialStats.InitialApr
            window
            settlementPartPeriod
            unitPeriod
            bp.PaymentConfig.Rounding

    /// calculates an amortisation schedule detailing how elements (principal, fee, interest and charges) are paid off over time
    let internal calculate (p: Parameters) initialStats (appliedPayments: Map<int<OffsetDay>, AppliedPayment>) =
        // get the evaluation day (the day the schedule is evaluated) based on the evaluation date in the schedule parameters
        let evaluationDay = (p.Basic.EvaluationDate - p.Basic.StartDate).Days * 1<OffsetDay>

        // get the decimal initial interest balance (interest is generally calculated as a decimal until concretised as an interest portion, at which point it is rounded to an integer)
        let initialInterestBalanceM = Cent.toDecimalCent initialStats.InitialInterestBalance

        // calculate the total fee value for the entire schedule
        let feeTotal = Fee.total p.Basic.FeeConfig p.Basic.Principal

        // gets an array of daily interest rates for a given date range, taking into account grace periods and promotional rates
        let dailyInterestRates fromDay toDay =
            Interest.dailyRates
                p.Basic.StartDate
                (isSettledWithinGracePeriod p)
                p.Basic.InterestConfig.StandardRate
                p.Advanced.InterestConfig.PromotionalRates
                fromDay
                toDay

        // get the interest rounding method from the schedule parameters (usually it is advisable to round interest down to avoid exceeding caps)
        let interestRounding = p.Basic.InterestConfig.Rounding

        // get stats for interest rounding at the end of the schedule
        let maxAppliedPaymentDay = appliedPayments |> Map.keys |> Seq.max
        let appliedPaymentCount = appliedPayments |> Map.count

        // return the amortisation schedule
        appliedPayments

        // convert the map to an array to allow scanning
        |> Map.toArray

        // generate the amortisation schedule
        |> Array.scan
            (fun ((previousDay, previous), a) (currentDay, current) ->
                // determine the window and increment every time a new scheduled payment is due
                let window =
                    if ScheduledPayment.isSome current.ScheduledPayment then
                        previous.Window + 1
                    else
                        previous.Window

                // get an array of advances
                // note: assumes single advance on day 0 (multiple advances are not currently supported), so this is based purely on the principal
                let advances =
                    if currentDay = 0<OffsetDay> then
                        [| p.Basic.Principal |]
                    else
                        [||]

                // calculates the actuarial interest that has accrued since the previous item
                let actuarialInterestM =
                    // if the principal balance is negative, apply any rate on negative balances and disregard any daily interest caps
                    if previous.PrincipalBalance <= 0L<Cent> then
                        dailyInterestRates previousDay currentDay
                        |> Array.map (fun dr -> {
                            dr with
                                InterestRate = p.Advanced.InterestConfig.RateOnNegativeBalance
                        })
                        |> Interest.calculate
                            (previous.PrincipalBalance + previous.FeeBalance)
                            Amount.Unlimited
                            interestRounding
                    // otherwise, apply the daily interest rates as normal, applied daily caps as necessary
                    else
                        dailyInterestRates previousDay currentDay
                        |> Interest.calculate
                            (previous.PrincipalBalance + previous.FeeBalance)
                            p.Basic.InterestConfig.Cap.DailyAmount
                            interestRounding

                // of the actual payments made on the day, sum any that are confirmed or written off
                let confirmedPaymentTotal =
                    current.ActualPayments
                    |> Array.sumBy (fun ap ->
                        match ap.ActualPaymentStatus with
                        | ActualPaymentStatus.Confirmed ap -> ap
                        | ActualPaymentStatus.WriteOff ap -> ap
                        | _ -> 0L<Cent>
                    )

                // cap the actuarial interest against the total interest cap
                let cappedActuarialInterestM =
                    Interest.Cap.cappedAddedValue
                        p.Basic.InterestConfig.Cap.TotalAmount
                        p.Basic.Principal
                        a.CumulativeActuarialInterestM
                        actuarialInterestM

                // apply the cumulative actuarial interest to the accumulator
                let accumulator = {
                    a with
                        CumulativeActuarialInterestM = a.CumulativeActuarialInterestM + cappedActuarialInterestM
                }

                // calculate any new interest accrued since the previous item, according to the interest method supplied in the schedule parameters
                let newInterestM =
                    match p.Basic.InterestConfig.Method with
                    | Interest.Method.AddOn ->
                        if previous.BalanceStatus <> ClosedBalance then
                            a.CumulativeActuarialInterestM + cappedActuarialInterestM
                            |> fun i ->
                                if i > initialInterestBalanceM then
                                    i - initialInterestBalanceM
                                else
                                    0m<Cent>
                            |> min cappedActuarialInterestM
                        else
                            0m<Cent>
                    | Interest.Method.Actuarial -> actuarialInterestM

                // ignore small amounts of interest that have accumulated by the last day of the schedule, with the allowance being proportional to the length of the schedule
                let calculateSettlementReduction m =
                    if currentDay = maxAppliedPaymentDay then
                        m - Interest.ignoreFractionalCents appliedPaymentCount m
                    else
                        0m<Cent>

                // cap the new interest against the total interest cap
                let cappedNewInterestM, settlementReductionM =
                    let cni =
                        Interest.Cap.cappedAddedValue
                            p.Basic.InterestConfig.Cap.TotalAmount
                            p.Basic.Principal
                            a.CumulativeInterest
                            newInterestM

                    let sr = calculateSettlementReduction cni |> max 0m<Cent>
                    cni - sr, sr

                // get the rounded settlement reduction
                let settlementReductionL =
                    settlementReductionM |> Cent.fromDecimalCent interestRounding

                // of the actual payments made on the day, sum any that are still pending
                let pendingPaymentTotal =
                    current.ActualPayments
                    |> Array.sumBy (fun ap ->
                        match ap.ActualPaymentStatus with
                        | ActualPaymentStatus.Pending ap -> ap
                        | _ -> 0L<Cent>
                    )

                // apportion the interest
                let interestPortionM =
                    // if a refund is made and the settlement figure is postive, the payment should be apportioned to principal rather than interest (this likely represents a goodwill gesture so should directly benefit the customer)
                    if confirmedPaymentTotal < 0L<Cent> && previous.SettlementFigure >= 0L<Cent> then
                        0m<Cent>
                    // otherwise, add new interest to the interest balance as normal
                    else
                        cappedNewInterestM + previous.InterestBalance

                // get the rounded interest portion
                let interestPortionL = interestPortionM |> Cent.fromDecimalCent interestRounding

                // update the accumulator
                let accumulator = {
                    accumulator with
                        CumulativeScheduledPayments =
                            a.CumulativeScheduledPayments + ScheduledPayment.total current.ScheduledPayment
                        CumulativeActualPayments =
                            a.CumulativeActualPayments + confirmedPaymentTotal + pendingPaymentTotal
                        CumulativeInterest = a.CumulativeInterest + cappedNewInterestM
                }

                // keep track of any excess payments made to offset against future payments due
                let extraPaymentsBalance =
                    a.CumulativeActualPayments
                    - a.CumulativeScheduledPayments
                    - a.CumulativeGeneratedPayments

                // get the payment due
                let paymentDue =
                    calculatePaymentDue
                        previous
                        current.ScheduledPayment.Original
                        current.ScheduledPayment.Rescheduled
                        extraPaymentsBalance
                        interestPortionL
                        p.Advanced.PaymentConfig.Minimum

                // determine the total of any underpayment
                let underpaymentTotal =
                    match current.PaymentStatus with
                    | MissedPayment -> paymentDue
                    | Underpayment -> paymentDue - current.NetEffect
                    | _ -> 0L<Cent>

                // determine the total and details of any charges incurred
                let newChargesTotal, incurredCharges =
                    if paymentDue = 0L<Cent> then
                        0L<Cent>, [||]
                    else
                        current.AppliedCharges |> Array.sumBy _.Total, current.AppliedCharges

                // apportion the charges
                let chargesPortion = newChargesTotal + previous.ChargesBalance |> max 0L<Cent>

                // for future days, assume that the payment will be made in full and on schedule, yielding a full net effect and allowing meaningful evaluation of the future schedule
                // (e.g. seeing if the schedule will be settled as agreed)
                let netEffect =
                    if currentDay > evaluationDay then
                        min current.NetEffect paymentDue
                    else
                        current.NetEffect

                // simplifies any refund apportionment by modifying the sign of certain values depending on whether the net effect is positive or negative
                let sign: int64<Cent> -> int64<Cent> =
                    if netEffect < 0L<Cent> then ((*) -1L) else id

                // get the rounded cumulative actuarial interest
                let cumulativeActuarialInterestL =
                    accumulator.CumulativeActuarialInterestM
                    |> Cent.fromDecimalCent interestRounding

                // get the basic settlement figure
                let settlement =
                    p.Basic.Principal + cumulativeActuarialInterestL
                    - accumulator.CumulativeActualPayments
                    |> fun s ->
                        if abs s < int64 appliedPaymentCount * 1L<Cent> then
                            0L<Cent>
                        else
                            s

                // get a settlement figure for the add-on interest method based on the actual actuarial interest accrued up to now
                let generatedSettlementPayment =
                    match p.Basic.InterestConfig.Method with
                    | Interest.Method.AddOn when previous.BalanceStatus <> ClosedBalance ->
                        settlement - settlementReductionL
                    | _ -> 0L<Cent>

                // determine whether an interest adjustment is required based on the difference between cumulative actuarial interest and the initial interest balance
                let interestAdjustmentM =
                    match p.Basic.InterestConfig.Method with
                    | Interest.Method.AddOn when previous.BalanceStatus <> ClosedBalance ->
                        let interestAdjustment =
                            if
                                (current.GeneratedPayment = ToBeGenerated || settlement <= 0L<Cent>)
                                && previous.BalanceStatus <> RefundDue
                                && cappedNewInterestM = 0m<Cent>
                            then // cappedNewInterest check here avoids adding an interest adjustment twice (one for generated payment, one for final payment)
                                accumulator.CumulativeActuarialInterestM - initialInterestBalanceM
                                |> Interest.ignoreFractionalCents 1
                                |> Interest.Cap.cappedAddedValue
                                    p.Basic.InterestConfig.Cap.TotalAmount
                                    p.Basic.Principal
                                    accumulator.CumulativeActuarialInterestM
                            else
                                0m<Cent>

                        interestAdjustment
                    | _ -> 0m<Cent>

                // refine the capped new interest value using any interest adjustment
                let cappedNewInterestM' = cappedNewInterestM + interestAdjustmentM

                // get the rounded value of the interest adjustment
                let interestAdjustmentL =
                    interestAdjustmentM |> Cent.fromDecimalCent interestRounding

                // refine the interest portion based on any interest adjustment, and again check against the total interest cap
                let interestPortionL' =
                    interestPortionL + interestAdjustmentL
                    |> Cent.toDecimalCent
                    |> Interest.Cap.cappedAddedValue
                        p.Basic.InterestConfig.Cap.TotalAmount
                        p.Basic.Principal
                        (Cent.toDecimalCent a.CumulativeInterestPortions)
                    |> Cent.fromDecimalCent interestRounding

                // determine how much of the net effect can be apportioned and whether any immediate adjustments need to be made to the scheduled payment due to charges and interest, depending on settings
                let assignable, scheduledPaymentAdjustment =
                    if netEffect = 0L<Cent> then
                        0L<Cent>, 0L<Cent>
                    else
                        match p.Advanced.PaymentConfig.ScheduledPaymentOption with
                        | AsScheduled -> sign netEffect - sign chargesPortion - sign interestPortionL', 0L<Cent>
                        | AddChargesAndInterest -> sign netEffect, sign chargesPortion - sign interestPortionL'

                // refine the scheduled payment with any adjustment
                let scheduledPayment = {
                    current.ScheduledPayment with
                        Adjustment = scheduledPaymentAdjustment
                }

                // apportion the fee
                let feePortion =
                    match p.Basic.FeeConfig with
                    | ValueSome feeConfig ->
                        match feeConfig.FeeAmortisation with
                        | Fee.FeeAmortisation.AmortiseBeforePrincipal -> min previous.FeeBalance assignable
                        | Fee.FeeAmortisation.AmortiseProportionately ->
                            feePercentage p.Basic.Principal feeTotal
                            |> Percent.toDecimal
                            |> fun m ->
                                if (1m + m) = 0m then
                                    0L<Cent>
                                else
                                    decimal assignable * m / (1m + m)
                                    |> Cent.round RoundUp
                                    |> max 0L<Cent>
                                    |> min previous.FeeBalance
                    | ValueNone -> 0L<Cent>

                // determine the value of any fee rebate in the event of settlement, depending on settings
                let feeRebateIfSettled =
                    match p.Advanced.FeeConfig with
                    | ValueSome feeConfig ->
                        match feeConfig.SettlementRebate with
                        | Fee.SettlementRebate.ProRata ->
                            let originalFinalPaymentDay =
                                p.Basic.ScheduleConfig
                                |> generatePaymentMap p.Basic.StartDate
                                |> Map.keys
                                |> Seq.toArray
                                |> Array.tryLast
                                |> Option.defaultValue 0<OffsetDay>

                            calculateFee feeTotal currentDay originalFinalPaymentDay
                        | Fee.SettlementRebate.ProRataRescheduled originalFinalPaymentDay ->
                            calculateFee feeTotal currentDay originalFinalPaymentDay
                        | Fee.SettlementRebate.Balance -> a.CumulativeFee
                        | Fee.SettlementRebate.Zero -> 0L<Cent>
                    | ValueNone -> 0L<Cent>

                // refine the settlement figure depending on the interest method
                let generatedSettlementPayment' =
                    match p.Basic.InterestConfig.Method with
                    | Interest.Method.AddOn -> generatedSettlementPayment
                    | _ ->
                        previous.PrincipalBalance + previous.FeeBalance - feeRebateIfSettled
                        + interestPortionL'
                        + chargesPortion

                // refine the fee portion and rebate if a rebate is actually applied on the day, i.e. if the net effect covers the settlement figure
                let feePortion', feeRebate =
                    if
                        current.GeneratedPayment.IsToBeGenerated
                        || feePortion > 0L<Cent> && generatedSettlementPayment' <= netEffect
                    then
                        let feeRebate' =
                            match p.Basic.InterestConfig.AprMethod with
                            | Apr.CalculationMethod.UnitedKingdom _ when feeRebateIfSettled > 0L<Cent> ->
                                // if the statutory rebate is higher than the fee rebate calculated above, use the higher figure
                                calculateStatutoryFeeRebate p.Basic appliedPayments initialStats currentDay window
                                |> max feeRebateIfSettled
                                |> min feeTotal
                            | _ -> feeRebateIfSettled

                        max 0L<Cent> (previous.FeeBalance - feeRebate'), feeRebate'
                    else
                        sign feePortion, 0L<Cent>

                // apportion the principal
                let principalPortion = max 0L<Cent> (assignable - feePortion')

                // calculate the principal balance
                let principalBalance = previous.PrincipalBalance - sign principalPortion

                // if any future payment creates a negative principal balance, adjust these figures accordingly
                let paymentDue', netEffect', principalPortion', principalBalance' =
                    if
                        current.PaymentStatus = NotYetDue
                        && feeRebate > 0L<Cent>
                        && principalBalance < 0L<Cent>
                    then
                        paymentDue + principalBalance,
                        netEffect + principalBalance,
                        sign principalPortion + principalBalance,
                        0L<Cent>
                    else
                        paymentDue, netEffect, sign principalPortion, principalBalance

                // if any charges or interest are not fully covered by the actual payment total, determine the values to carry over to the next item
                let carriedCharges, carriedInterestL =
                    if sign chargesPortion > sign netEffect then
                        chargesPortion - netEffect, interestPortionL
                    elif netEffect = 0L<Cent> && interestPortionM < 0m<Cent> then
                        0L<Cent>, interestPortionL
                    elif sign chargesPortion + sign interestPortionL' > sign netEffect then
                        0L<Cent>, interestPortionL - (netEffect - chargesPortion)
                    else
                        0L<Cent>, 0L<Cent>

                // get the date equivalent of the offset day for further calculation
                let offsetDate = p.Basic.StartDate.AddDays(int currentDay)

                // determine the principal balance
                let balanceStatus = getBalanceStatus principalBalance'

                // calculate the interest balance as a decimal
                let interestBalanceM =
                    previous.InterestBalance + cappedNewInterestM'
                    - Cent.toDecimalCent (interestPortionL' - carriedInterestL)

                // get the rounded interest balance
                let interestBalanceL = interestBalanceM |> decimal |> Cent.round interestRounding

                // creates an item that optionally creates a settlement
                let createScheduleItem isSettlement =
                    // refine the payment status based on the balance status and whether this is a settlement
                    let paymentStatus =
                        match previous.BalanceStatus, isSettlement with
                        | ClosedBalance, _ when current.PaymentStatus.IsInformationOnly -> InformationOnly
                        | ClosedBalance, _ -> NoLongerRequired
                        | _, true -> Generated
                        | RefundDue, _ when netEffect' < 0L<Cent> -> Refunded
                        | RefundDue, _ when netEffect' > 0L<Cent> -> Overpayment
                        | RefundDue, _ when current.PaymentStatus.IsInformationOnly -> InformationOnly
                        | RefundDue, _ -> NoLongerRequired
                        | _ when
                            current.PaymentStatus <> InformationOnly
                            && paymentDue' = 0L<Cent>
                            && confirmedPaymentTotal = 0L<Cent>
                            && pendingPaymentTotal = 0L<Cent>
                            && GeneratedPayment.total current.GeneratedPayment = 0L<Cent>
                            ->
                            NothingDue
                        | _ -> current.PaymentStatus

                    // refine the settlement figure if necessary by subtracting any payment made on the same day, or nullifying it if there are payments pending (settlement cannot be made in this case)
                    let settlementFigure =
                        match pendingPaymentTotal, current.PaymentStatus, p.Basic.InterestConfig.Method with
                        | pp, _, _ when pp > 0L<Cent> -> 0L<Cent>
                        | _, NotYetDue, _
                        | _, _, Interest.Method.AddOn -> generatedSettlementPayment'
                        | _ -> generatedSettlementPayment' - netEffect'

                    // deteremine the settlement balances or carried balances
                    let balances, interestPortionL', generatedPayment =
                        if isSettlement then
                            // convert the generated payment placeholder with an actual settlement figure
                            (0L<Cent>, 0L<Cent>, 0m<Cent>, 0L<Cent>),
                            interestPortionL',
                            match current.GeneratedPayment with
                            | ToBeGenerated -> GeneratedValue settlementFigure
                            | gp -> gp
                        else
                            // refine the interest portion by adding carried interest, and calculate the balances
                            let feeBalance = previous.FeeBalance - feePortion' - feeRebate
                            let interestBalance = interestBalanceM |> Interest.ignoreFractionalCents 1

                            let chargesBalance =
                                previous.ChargesBalance + newChargesTotal - chargesPortion + carriedCharges

                            (principalBalance', feeBalance, interestBalance, chargesBalance),
                            interestPortionL' - carriedInterestL,
                            current.GeneratedPayment

                    // assign the separate balances
                    let principalBal, feeBal, interestBal, chargesBal = balances

                    // ensure the settlement figure is never more than the total balances
                    let balanceTotal =
                        principalBal
                        + feeBal
                        + Cent.fromDecimalCent p.Basic.InterestConfig.Rounding interestBal
                        + chargesBal

                    let settlementFigure' =
                        (balanceTotal, settlementFigure)
                        ||> if settlementFigure < 0L<Cent> then max else min

                    //determine the type of offset day
                    let offsetDayType =
                        if isSettlement then SettlementDay
                        elif currentDay = evaluationDay then EvaluationDay
                        else OffsetDay

                    // create the schedule item
                    let scheduleItem = {
                        OffsetDayType = offsetDayType
                        OffsetDate = offsetDate
                        Advances = advances
                        ScheduledPayment = scheduledPayment
                        Window = window
                        PaymentDue = paymentDue'
                        ActualPayments = current.ActualPayments
                        GeneratedPayment = generatedPayment
                        NetEffect =
                            if isSettlement then
                                netEffect + GeneratedPayment.total generatedPayment
                            else
                                netEffect'
                        PaymentStatus = paymentStatus
                        BalanceStatus = if isSettlement then ClosedBalance else balanceStatus
                        ActuarialInterest = cappedActuarialInterestM
                        NewInterest = cappedNewInterestM'
                        NewCharges = incurredCharges
                        PrincipalPortion =
                            if isSettlement then
                                previous.PrincipalBalance
                            else
                                principalPortion'
                        FeePortion =
                            if isSettlement then
                                previous.FeeBalance - feeRebate
                            else
                                feePortion'
                        InterestPortion = interestPortionL'
                        ChargesPortion =
                            if isSettlement then
                                chargesPortion
                            else
                                chargesPortion - carriedCharges
                        FeeRebate = feeRebate
                        PrincipalBalance = principalBal
                        FeeBalance = feeBal
                        InterestBalance = interestBal
                        ChargesBalance = chargesBal
                        SettlementFigure = settlementFigure'
                        FeeRebateIfSettled =
                            if not isSettlement && paymentStatus = NoLongerRequired then
                                0L<Cent>
                            else
                                feeRebateIfSettled
                    }

                    // calculate the rounding difference between the decimal and integer interest balances
                    let interestRoundingDifferenceM =
                        if not isSettlement && interestPortionL' = 0L<Cent> then
                            0m<Cent>
                        else
                            interestBalanceM - Cent.toDecimalCent interestBalanceL

                    // returns the offset day, schedule item, generated payment, and interest rounding difference (zero in this case as it is already factored into the settlement figure)
                    currentDay,
                    scheduleItem,
                    (if isSettlement then settlementFigure' else 0L<Cent>),
                    interestRoundingDifferenceM

                // get the relevant type of item based on the intended purpose
                let offsetDay, scheduleItem, generatedPayment, interestRoundingDifferenceM =
                    match current.GeneratedPayment, p.Advanced.SettlementDay with
                    | ToBeGenerated, SettlementDay.SettlementOnEvaluationDay when evaluationDay = currentDay ->
                        createScheduleItem true
                    | GeneratedValue gv, _ -> failwith $"Unexpected value: <i>{gv}</i>"
                    | NoGeneratedPayment, _
                    | ToBeGenerated, SettlementDay.NoSettlement
                    | ToBeGenerated, SettlementDay.SettlementOnEvaluationDay -> createScheduleItem false

                // refine the accumulator values
                let accumulator' = {
                    accumulator with
                        CumulativeScheduledPayments =
                            accumulator.CumulativeScheduledPayments + scheduledPaymentAdjustment
                        CumulativeGeneratedPayments = a.CumulativeGeneratedPayments + generatedPayment
                        CumulativeFee = a.CumulativeFee + feePortion'
                        CumulativeInterest = accumulator.CumulativeInterest - interestRoundingDifferenceM
                        CumulativeInterestPortions = a.CumulativeInterestPortions + scheduleItem.InterestPortion
                }
                // return the values for the next scan iteration
                (offsetDay, scheduleItem), accumulator'
            )
            (
            // initialise the values for the scan
            (0<OffsetDay>,
             {
                 ScheduleItem.zero with
                     OffsetDate = p.Basic.StartDate
                     Advances = [| p.Basic.Principal |]
                     PrincipalBalance = p.Basic.Principal
                     FeeBalance = feeTotal
                     InterestBalance = initialInterestBalanceM
                     SettlementFigure = p.Basic.Principal + feeTotal
                     FeeRebateIfSettled =
                         match p.Advanced.FeeConfig with
                         | ValueSome fc ->
                             match fc.SettlementRebate with
                             | Fee.SettlementRebate.Zero -> 0L<Cent>
                             | _ -> feeTotal
                         | ValueNone -> 0L<Cent>
             }),
            {
                CumulativeScheduledPayments = 0L<Cent>
                CumulativeActualPayments = 0L<Cent>
                CumulativeGeneratedPayments = 0L<Cent>
                CumulativeFee = 0L<Cent>
                CumulativeInterest = initialInterestBalanceM
                CumulativeInterestPortions = 0L<Cent>
                CumulativeActuarialInterestM = 0m<Cent>
            })
        // separate and discard the accumulator
        |> Array.unzip
        |> fst
        // handle duplicated initial offset day
        |> fun a ->
            if
                a
                |> Array.filter (fun (siOffsetDay, _) -> siOffsetDay = 0<OffsetDay>)
                |> Array.length = 2
            then
                a |> Array.tail
            else
                a
        // post-process missed payments or underpayments
        |> markMissedPaymentsAsLate

    /// wraps the amortisation schedule in some statistics, and optionally calculates the final APR (optional because it can be processor-intensive)
    let calculateStats (items: Map<int<OffsetDay>, ScheduleItem>) =
        let finalItemDay, finalItem = items |> Map.maxKeyValue
        let items' = items |> Map.toArray |> Array.map snd
        let principalTotal = items' |> Array.sumBy _.PrincipalPortion
        let feeTotal = items' |> Array.sumBy _.FeePortion
        let interestTotal = items' |> Array.sumBy _.InterestPortion
        let chargesTotal = items' |> Array.sumBy _.ChargesPortion
        let feeRebate = finalItem.FeeRebate
        let finalPaymentDay = finalItemDay

        let requiredScheduledPaymentItems =
            items
            |> Map.filter (fun _ si ->
                ScheduledPayment.isSome si.ScheduledPayment
                && not si.PaymentStatus.IsNoLongerRequired
            )

        let actualPaymentItems =
            items |> Map.filter (fun _ si -> si.ActualPayments.Length > 0)

        {
            ScheduleItems = items
            FinalStats = {
                RequiredScheduledPaymentCount = requiredScheduledPaymentItems |> Map.count
                LastRequiredScheduledPaymentDay =
                    if Map.count requiredScheduledPaymentItems = 0 then
                        ValueNone
                    else
                        requiredScheduledPaymentItems |> Map.maxKeyValue |> fst |> ValueSome
                FinalActualPaymentCount = items' |> Array.sumBy (fun asi -> Array.length asi.ActualPayments)
                LastActualPaymentDay =
                    if Map.count actualPaymentItems = 0 then
                        ValueNone
                    else
                        actualPaymentItems |> Map.maxKeyValue |> fst |> ValueSome
                FinalCostToBorrowingRatio =
                    if principalTotal = 0L<Cent> then
                        Percent 0m
                    else
                        decimal (feeTotal + interestTotal + chargesTotal) / decimal principalTotal
                        |> Percent.fromDecimal
                        |> Percent.round 2
                EffectiveInterestRate =
                    if
                        finalPaymentDay = 0<OffsetDay>
                        || principalTotal + feeTotal - feeRebate = 0L<Cent>
                    then
                        0m
                    else
                        decimal interestTotal
                        / decimal (principalTotal + feeTotal - feeRebate)
                        / decimal finalPaymentDay
                    |> Percent.fromDecimal
                    |> Interest.Rate.Daily
                SettlementFigure =
                    items
                    |> Map.tryPick (fun d si ->
                        match si.GeneratedPayment with
                        | GeneratedValue gv -> Some(d, gv)
                        | _ -> None
                    )
                    |> toValueOption
                FinalBalanceStatus = items |> Map.maxKeyValue |> snd |> _.BalanceStatus
            }
        }

    /// generates an amortisation schedule and final statistics
    let amortise (p: Parameters) actualPayments =
        let basicSchedule = calculateBasicSchedule p.Basic

        let scheduledPayments =
            basicSchedule.Items
            |> Array.filter (_.ScheduledPayment >> ScheduledPayment.isSome)
            |> Array.map (fun si ->
                si.Day,
                {
                    si.ScheduledPayment with
                        Original = si.ScheduledPayment.Original
                }
            )
            |> Map.ofArray

        let amortisationSchedule =
            scheduledPayments
            |> applyPayments p actualPayments
            |> calculate p basicSchedule.Stats
            |> if p.Advanced.TrimEnd then
                   Map.filter (fun _ si -> si.PaymentStatus <> NoLongerRequired || si.BalanceStatus = RefundDue)
               else
                   id
            |> calculateStats

        {
            AmortisationSchedule = amortisationSchedule
            BasicSchedule = basicSchedule
        }
